<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.2.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://fastly.jsdelivr.net'>
  <link rel="preconnect" href="https://fastly.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>Software_Testing_Learning_Note - Fam044's Blog</title>

  
    <meta name="description" content="以下内容全部来自慕课网课程 《从零开始学测试 一步迈向互联网》，本文仅用于学习整理如有侵权，请联系删除本文 软件测试的发展和职业规划软件测试发展与职业生涯规划 软件测试 技术方向 黑盒测试 白盒测试 自动化测试 性能测试 安全测试 测试架构   管理方向 测试经理 项目经理 SCRUM MASTER   业务方向 测试专家 需求 产品经理 金融等行业精英      软件测试之“独孤九剑” 软件测试">
<meta property="og:type" content="article">
<meta property="og:title" content="Software_Testing_Learning_Note">
<meta property="og:url" content="https://fam044.github.io/2022/06/11/Software-Testing-Learning-Note/index.html">
<meta property="og:site_name" content="Fam044&#39;s Blog">
<meta property="og:description" content="以下内容全部来自慕课网课程 《从零开始学测试 一步迈向互联网》，本文仅用于学习整理如有侵权，请联系删除本文 软件测试的发展和职业规划软件测试发展与职业生涯规划 软件测试 技术方向 黑盒测试 白盒测试 自动化测试 性能测试 安全测试 测试架构   管理方向 测试经理 项目经理 SCRUM MASTER   业务方向 测试专家 需求 产品经理 金融等行业精英      软件测试之“独孤九剑” 软件测试">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/37547176b8fa48c098f21584de30de0e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b32ad05581ab47a1b6f9e24d8308a6e5.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/000381b057c547d4bafe51114795b42c.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/157e96bd89a8454995bcfeb663d8f35a.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1d5f0bfa19964673a6c3ca14efb0439b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/656847ce6a3f427ea524f6ac01c163c9.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/7eb97ce992a549fe90973d1e6959b630.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9baebe971e1e479ebf0cbd97c5c4625f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/298c92f9a7fe4fab8a3f5e545be50b43.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4b91f5b1ce564e7cb87e01ae0756880b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2d1cb0c866864b28b624838e49a2cc0a.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b2109b461e5c4596b7d296d0c97bba42.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/c1e47dfea67149f29c5d3ec81a650a32.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/03cdf7fef57c4feaa29c3f7877686059.png">
<meta property="article:published_time" content="2022-06-11T02:55:13.000Z">
<meta property="article:modified_time" content="2022-07-16T01:19:12.696Z">
<meta property="article:author" content="Fam044">
<meta property="article:tag" content="SoftwareTesting">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/37547176b8fa48c098f21584de30de0e.png">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="title" href="/"><div class="main">Fam044's Blog</div></a></div>
<nav class="menu dis-select"></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92"><span class="toc-text">软件测试的发展和职业规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%8F%91%E5%B1%95%E4%B8%8E%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92"><span class="toc-text">软件测试发展与职业生涯规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E2%80%9C%E7%8B%AC%E5%AD%A4%E4%B9%9D%E5%89%91%E2%80%9D"><span class="toc-text">软件测试之“独孤九剑”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%88%B0%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-text">从软件工程到软件测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">软件的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%8D%81%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">软件的十大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">软件的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">软件生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%B8%80%E7%94%9F"><span class="toc-text">软件的一生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="toc-text">软件开发模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%E2%80%93%E5%AD%A6%E4%BC%9A%E5%86%99%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3"><span class="toc-text">软件开发文档–学会写测试文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E8%BF%9B%E7%A8%8B"><span class="toc-text">项目进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5"><span class="toc-text">软件测试概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-text">软件测试方法和分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E7%BB%86%E5%88%86%E9%97%AE%E9%A2%98"><span class="toc-text">性能测试的细分问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-text">生命周期各测试方法对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD"><span class="toc-text">软件测试常见术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B"><span class="toc-text">软件测试常见模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87"><span class="toc-text">软件测试覆盖率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%E7%9A%84%E8%BF%90%E7%94%A8"><span class="toc-text">测试覆盖率的运用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%E7%9A%84%E6%9C%80%E7%BB%88%E6%84%8F%E4%B9%89"><span class="toc-text">测试覆盖率的最终意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87"><span class="toc-text">理解测试覆盖率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E9%9C%80%E8%A6%81%E7%9A%84%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB"><span class="toc-text">软件测试人员需要的知识体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E5%85%B7%E5%A4%87%E7%9A%84%E7%B4%A0%E8%B4%A8"><span class="toc-text">软件测试人员具备的素质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text">软件测试的原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B"><span class="toc-text">软件测试流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8E%9F%E5%88%99"><span class="toc-text">软件测试环境搭建原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">搭建测试环境过程分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-text">测试环境配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E6%A8%A1%E5%BC%8F"><span class="toc-text">Docker模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B9%B3%E5%8F%B0"><span class="toc-text">依赖第三方平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E8%B0%88%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E5%BB%BA%E8%AE%BE%E8%90%BD%E5%9C%B0"><span class="toc-text">浅谈测试环境的建设落地</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%BB%BA%E8%AE%BE%E6%80%9D%E8%B7%AF"><span class="toc-text">环境建设思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B"><span class="toc-text">简单的测试过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E5%88%92%E5%88%86"><span class="toc-text">测试过程划分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%AD%96%E5%88%92%E8%BF%87%E7%A8%8B"><span class="toc-text">测试策划过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E6%B5%8B%E8%AF%95"><span class="toc-text">需求测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">需求测试的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E9%AA%8C%E8%AF%81"><span class="toc-text">需求验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%A3%80%E6%9F%A5%E5%88%97%E8%A1%A8"><span class="toc-text">需求规格说明书检查列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5"><span class="toc-text">测试策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%89%8D%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-text">测试前的思考</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">测试策略是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5%E8%A6%81%E7%B4%A0"><span class="toc-text">测试策略要素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92%E4%B8%8E%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88"><span class="toc-text">测试计划与测试方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5-vs-%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92-vs-%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88"><span class="toc-text">测试策略 vs 测试计划 vs 测试方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E5%88%97%E8%A1%A8"><span class="toc-text">测试方案列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E8%AF%84%E5%AE%A1"><span class="toc-text">测试方案评审</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">软件测试设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">测试设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="toc-text">测试分析和设计的主要任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%B5%8B%E8%AF%95%E6%9D%A1%E4%BB%B6"><span class="toc-text">确定测试条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-text">测试用例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E5%8C%85%E6%8B%AC%E4%BB%A5%E4%B8%8B%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-text">测试用例设计包括以下关键点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E6%A1%88%E4%BE%8B"><span class="toc-text">测试用例案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-text">测试用例常用设计方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E6%B3%95"><span class="toc-text">等价类划分法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E6%96%B9%E6%B3%95"><span class="toc-text">等价类划分方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E7%9A%84%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1"><span class="toc-text">基于等价类划分的用例设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E5%AE%9E%E6%88%98"><span class="toc-text">等价类划分实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">等价类的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">等价类划分要注意的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E6%B3%95"><span class="toc-text">边界值法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-text">边界值分析法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text">边界值设计的原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%9B%BE-amp-%E5%88%A4%E5%AE%9A%E8%A1%A8"><span class="toc-text">因果图&amp;判定表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%9B%BE%E6%B3%95"><span class="toc-text">因果图法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%9B%BE-%E5%88%A4%E5%AE%9A%E8%A1%A8"><span class="toc-text">因果图-判定表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E8%A1%A8"><span class="toc-text">判定表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4%EF%BC%88%E5%9B%A0%E6%9E%9C%E5%9B%BE-amp-%E5%88%A4%E5%AE%9A%E8%A1%A8%EF%BC%89"><span class="toc-text">设计步骤（因果图&amp;判定表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E4%BA%A4%E5%AE%9E%E9%AA%8C%E6%B3%95"><span class="toc-text">正交实验法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E4%BA%A4%E5%AE%9E%E9%AA%8C%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4"><span class="toc-text">正交实验法设计步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E6%AD%A3%E4%BA%A4%E8%A1%A8"><span class="toc-text">如何查找正交表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1"><span class="toc-text">测试场景设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1"><span class="toc-text">场景法基础设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8"><span class="toc-text">用例设计的综合运用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E7%AE%A1%E7%90%86"><span class="toc-text">测试执行管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">测试执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="toc-text">测试执行阶段的主要任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%87%86%E5%85%A5%E5%87%86%E5%87%BA"><span class="toc-text">测试准入准出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%87%86%E5%85%A5%E6%A0%87%E5%87%86"><span class="toc-text">测试准入标准</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%9A%82%E5%81%9C%E3%80%81%E5%81%9C%E6%AD%A2"><span class="toc-text">测试暂停、停止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%87%86%E5%87%BA%E6%A0%87%E5%87%86"><span class="toc-text">测试准出标准</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E7%AE%A1%E7%90%86"><span class="toc-text">缺陷管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7"><span class="toc-text">软件缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7"><span class="toc-text">什么是软件缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">缺陷产生的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E7%8E%B0%E7%BC%BA%E9%99%B7"><span class="toc-text">发现缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E2%80%93%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">缺陷报告–注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BUG%E9%87%8D%E7%8E%B0"><span class="toc-text">BUG重现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E9%87%8D%E7%8E%B0%E7%9A%84BUG"><span class="toc-text">无法重现的BUG</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A"><span class="toc-text">缺陷报告</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E5%8C%85%E5%90%AB%E4%BF%A1%E6%81%AF"><span class="toc-text">缺陷报告包含信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E7%9A%84%E5%86%99%E4%BD%9C%E5%87%86%E5%88%99%EF%BC%885C%EF%BC%89"><span class="toc-text">缺陷报告的写作准则（5C）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E7%9A%84%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84"><span class="toc-text">缺陷报告的组织架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%A0%87%E9%A2%98"><span class="toc-text">缺陷标题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7"><span class="toc-text">缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-text">复现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">缺陷报告注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text">缺陷报告的原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E8%B7%9F%E8%B8%AA"><span class="toc-text">缺陷跟踪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E8%B7%9F%E8%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">缺陷跟踪管理系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%85%E9%81%93%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">禅道项目管理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2"><span class="toc-text">用户角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E4%BD%BF%E7%94%A8"><span class="toc-text">最简使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-text">项目模式基本流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%93%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95"><span class="toc-text">易用性测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%93%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95%E5%86%85%E5%AE%B9"><span class="toc-text">易用性测试内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-text">测试点总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6%E7%B1%BB"><span class="toc-text">控件类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-text">菜单测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%BE%E7%BD%AE"><span class="toc-text">快捷键设置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95"><span class="toc-text">兼容性测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E2%80%93%E5%88%86%E7%B1%BB"><span class="toc-text">兼容性测试–分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E2%80%93%E4%BD%9C%E7%94%A8"><span class="toc-text">兼容性测试–作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Web%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95"><span class="toc-text">Web兼容性测试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Web%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E5%90%91"><span class="toc-text">Web兼容性测试方向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-text">测试方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E9%80%89%E5%9E%8B"><span class="toc-text">测试选型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E2%80%93IETESTER"><span class="toc-text">三方工具–IETESTER</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E2%80%93BrowserShots"><span class="toc-text">三方工具–BrowserShots</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E2%80%93Super-Preview"><span class="toc-text">三方工具–Super Preview</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#APP%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95"><span class="toc-text">APP兼容性测试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#APP%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E5%90%91"><span class="toc-text">APP兼容性测试方向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-text">补充说明</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E9%A1%B9%E5%B8%B8%E7%94%A8%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF"><span class="toc-text">各项常用测试技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5"><span class="toc-text">白盒测试之代码审查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-text">代码审查的范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">代码审查的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text">代码审查的规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96"><span class="toc-text">白盒测试之逻辑覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%AF%B4%E8%B5%B7"><span class="toc-text">从单元测试说起</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1"><span class="toc-text">单元测试用例设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96%E6%B3%95"><span class="toc-text">逻辑覆盖法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%E8%A6%86%E7%9B%96"><span class="toc-text">语句覆盖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%E8%A6%86%E7%9B%96%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-text">语句覆盖的不足</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E8%A6%86%E7%9B%96"><span class="toc-text">判定覆盖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E8%A6%86%E7%9B%96%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-text">判定覆盖的不足</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%A6%86%E7%9B%96"><span class="toc-text">条件覆盖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%A6%86%E7%9B%96%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-text">条件覆盖的不足</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A-%E6%9D%A1%E4%BB%B6%E8%A6%86%E7%9B%96"><span class="toc-text">判定-条件覆盖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BB%84%E5%90%88%E8%A6%86%E7%9B%96"><span class="toc-text">条件组合覆盖</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0"><span class="toc-text">自动化测试概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-text">自动化测试的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-text">自动化测试应用场景分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84WEB%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-text">常用的WEB自动化测试工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#QTP"><span class="toc-text">QTP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Selenium-WebDriver"><span class="toc-text">Selenium(WebDriver)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UFT-Unified-Functional-Testing"><span class="toc-text">UFT(Unified Functional Testing)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RFT-IBM-Rational-Functional-Tester"><span class="toc-text">RFT(IBM Rational Functional Tester)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WINRUNNER"><span class="toc-text">WINRUNNER</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Sikuli"><span class="toc-text">Sikuli</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9"><span class="toc-text">自动化测试工具选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0"><span class="toc-text">安全测试概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">Web安全测试介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Web%E5%BA%94%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">Web应用的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Web%E5%BA%94%E7%94%A8%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-text">Web应用三层架构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E2%80%9C%E5%AE%89%E5%85%A8%E2%80%9D"><span class="toc-text">日常生活中的“安全”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8EWASC%E5%92%8COWASP%E8%B0%88%E6%BC%8F%E6%B4%9E%E5%88%86%E7%B1%BB"><span class="toc-text">从WASC和OWASP谈漏洞分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#WASC-Web-Application-Security-Consortium"><span class="toc-text">WASC(Web Application Security Consortium)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OWASAP-Open-Web-Application-Security-Project"><span class="toc-text">OWASAP(Open Web Application Security Project)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Web%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B"><span class="toc-text">Web安全测试流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%AE%A1%E8%AE%A1"><span class="toc-text">安全审计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%A1%E8%AE%A1%E5%B7%A5%E5%85%B7"><span class="toc-text">自动化审计工具</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AppScan%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%9B%A2%E9%98%9F%E4%B8%AD%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="toc-text">AppScan在项目团队中的协作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AppScan%E6%89%AB%E6%8F%8F%E8%8C%83%E5%9B%B4"><span class="toc-text">AppScan扫描范围</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E5%8E%9F%E7%90%86"><span class="toc-text">扫描原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AppScan%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-text">AppScan工作过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-text">性能测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AE%80%E4%BB%8B"><span class="toc-text">性能测试简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">性能测试的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0"><span class="toc-text">性能测试概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B4%BB%E5%8A%A8"><span class="toc-text">性能测试的核心活动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9B%AE%E6%A0%87"><span class="toc-text">性能测试目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">性能测试介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">性能测试的种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%B4%BB%E5%8A%A8"><span class="toc-text">核心性能测试活动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LoadRunner"><span class="toc-text">LoadRunner</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LoadRunner%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-text">LoadRunner主要特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LoadRunner%E5%B7%A5%E5%85%B7%E7%BB%84%E6%88%90"><span class="toc-text">LoadRunner工具组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LoadRunner%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">LoadRunner工作原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E6%9C%BAAPP%E6%B5%8B%E8%AF%95"><span class="toc-text">手机APP测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8APP%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">移动APP的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8APP%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">移动APP的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8APP%E6%B5%8B%E8%AF%95%E4%B8%8E%E4%BC%A0%E7%BB%9F%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">移动APP测试与传统测试的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#APP%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-text">APP测试方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-text">功能测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95"><span class="toc-text">专项测试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E6%B5%8B%E8%AF%95"><span class="toc-text">安装测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD%E6%B5%8B%E8%AF%95"><span class="toc-text">卸载测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E6%B5%8B%E8%AF%95"><span class="toc-text">交互测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%87%E7%BA%A7%E6%B5%8B%E8%AF%95"><span class="toc-text">升级测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95%EF%BC%89"><span class="toc-text">性能测试（专项测试）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UI%E6%B5%8B%E8%AF%95"><span class="toc-text">UI测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Appium"><span class="toc-text">Appium</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Appium%E7%AE%80%E4%BB%8B"><span class="toc-text">Appium简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Appium%E7%89%B9%E7%82%B9"><span class="toc-text">Appium特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Appium%E6%9E%B6%E6%9E%84"><span class="toc-text">Appium架构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#APP%E7%A8%B3%E5%AE%9A%E6%80%A7-amp-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E2%80%93Monkey"><span class="toc-text">APP稳定性&amp;性能测试工具–Monkey</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A"><span class="toc-text">软件测试报告</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">测试报告的内容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E6%94%B6%E6%B5%8B%E8%AF%95"><span class="toc-text">验收测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E6%94%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8A%A5%E5%91%8A"><span class="toc-text">验收测试的主要报告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E6%94%B6%E6%B5%8B%E8%AF%95%E4%BB%BB%E5%8A%A1"><span class="toc-text">验收测试任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E6%94%B6%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B"><span class="toc-text">验收测试过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E6%94%B6%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5"><span class="toc-text">验收测试策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%94%E8%AE%B0"><span class="toc-text">笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E2%80%93%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%8A%89%E6%8B%A9%EF%BC%9A"><span class="toc-text">测试用例设计–测试方法抉择：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%BB%BC%E5%90%88%E8%AE%BE%E8%AE%A1"><span class="toc-text">测试用例综合设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E8%AF%84%E5%AE%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">用例评审流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%BC%BA%E9%99%B7"><span class="toc-text">测试缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93%E9%98%B6%E6%AE%B5"><span class="toc-text">测试总结阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E9%98%B6%E6%AE%B5"><span class="toc-text">项目上线阶段</span></a></li></ol></li></ol></div></div></div>


</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/Fam044" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.3/social/08a41b181ce68.svg"/></a><a class="social" href="https://music.163.com/#/user/home?id=285668870" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.3/social/3845874.svg"/></a></div></footer>

    </aside>
    <div class='l_main'>
      

      

<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/SoftwareTesting/">SoftwareTesting</a></div><div id="post-meta">发布于&nbsp;<time datetime="2022-06-11T02:55:13.000Z">2022-06-11</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>Software_Testing_Learning_Note</span></h1>
<p><em>以下内容全部来自慕课网课程 <a href="https://coding.imooc.com/learn/list/411.html">《从零开始学测试 一步迈向互联网》</a>，本文仅用于学习整理<br>如有侵权，请联系删除本文</em></p>
<h2 id="软件测试的发展和职业规划"><a href="#软件测试的发展和职业规划" class="headerlink" title="软件测试的发展和职业规划"></a>软件测试的发展和职业规划</h2><h3 id="软件测试发展与职业生涯规划"><a href="#软件测试发展与职业生涯规划" class="headerlink" title="软件测试发展与职业生涯规划"></a>软件测试发展与职业生涯规划</h3><ul>
<li>软件测试<ul>
<li>技术方向<ul>
<li>黑盒测试</li>
<li>白盒测试</li>
<li>自动化测试</li>
<li>性能测试</li>
<li>安全测试</li>
<li>测试架构</li>
</ul>
</li>
<li>管理方向<ul>
<li>测试经理</li>
<li>项目经理</li>
<li>SCRUM MASTER</li>
</ul>
</li>
<li>业务方向<ul>
<li>测试专家</li>
<li>需求</li>
<li>产品经理</li>
<li>金融等行业精英</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="软件测试之“独孤九剑”"><a href="#软件测试之“独孤九剑”" class="headerlink" title="软件测试之“独孤九剑”"></a>软件测试之“独孤九剑”</h3><ol>
<li>软件测试基础知识<br>最重要的是夯实基础<br>了解测试流程，掌握测试各阶段所需的知识及技能，了解软件生存周期各阶段测试人员的职责</li>
<li>软件测试流程<br>测试流程是每个测试团队的核心，一个完善的流程才能造就一支高效的团队<br>要学习破解软件测试的流程及测试策略、计划、方案的编写与评审过程</li>
<li>软件测试设计<br>我们在开始测试时，并非要一步到位直接攻其核心，上手测试<br>需要从设计入手，这部分主要学习常用的测试需求分析、黑盒测试用例设计方法以及常用测试技术应用等</li>
<li>测试执行管理<br>主要学习测试用例的执行、测试的缺陷管理、跟踪及测试总结，熟悉各种测试文档的撰写</li>
<li>功能测试项目实践<br>将前面讲解的测试方法串联起来</li>
<li>测试技术深化<br>从自动化、性能、安全以及白盒测试方法的测试手段和方法，对软件测试技术进行进一步深化</li>
<li>手机APP测试<br>学习APP测试与WEB测试的不同点，常见的测试点，弱网、兼容性测试模式，并初步介绍APP自动化测试实现方法</li>
<li>测试总结<br>对测试过程及进行一个总结，有产出才是整个测试的总结</li>
<li>面试秘籍</li>
</ol>
<h2 id="从软件工程到软件测试"><a href="#从软件工程到软件测试" class="headerlink" title="从软件工程到软件测试"></a>从软件工程到软件测试</h2><h3 id="软件的概念"><a href="#软件的概念" class="headerlink" title="软件的概念"></a>软件的概念</h3><p>软件是计算机系统中与硬件相互依存的另一部分，它是包括程序，数据及其相关文档的完整集合<br>程序 是按实现设计的功能和性能要求执行的指令序列<br>数据 是使程序能正常操纵信息的数据结构<br>文档 是与程序开发，维护和使用有关的图文材料</p>
<h3 id="软件的十大特性"><a href="#软件的十大特性" class="headerlink" title="软件的十大特性"></a>软件的十大特性</h3><ol>
<li>形态特性<br>软件是无形的、不可见的逻辑实体。度量常规产品的几何尺寸、物理性质和化学成分对它却是毫无意义的</li>
<li>智能特性<br>软件是复杂的智力产品，它的开发凝聚了人们大量的脑力劳动，它本身也体现了知识实践经验和人类的指挥，具有一定的智能。它可以帮助我们解决复杂的计算、分析、判断和决策问题</li>
<li>开发特性<br>尽管已经有了一些工具（也是软件）来辅助软件开发工作，但到目前为止尚未实现自动化。软件开发中仍然包括了相当分量的个体劳动，使得这一大规模知识型工作充满了个人行为和个人因素</li>
<li>质量特性<br>软件是由人编写的，由于其开发特性存在，所以不存在完全没有缺陷的软件</li>
<li>生产特性<br>与硬件或传统的制造业商品的生产完全不同，软件一旦设计开发出来，如果需要提供多个用户，它的复制十分简单，其成本也极为有限</li>
<li>管理特性<br>由于上面的特性存在，所以软件过程中的管理显得更为重要，相比传统行业，也更为独特</li>
<li>环境特性<br>软件的开发与运行都离不开相关的计算机系统环境，包括支持它的开发和运行相关的硬件和软件。软件对于计算机系统的环境有着不可摆脱的依赖性</li>
<li>维护特性<br>软件投入使用后需要进行维护，但这种维护与传统产业产品的维护概念有着很大差别，维护体现在升级、优化、功能更新等方面，甚至可以全盘重构</li>
<li>废弃特性<br> 与硬件不同，软件并不是被“用坏”而是被废弃的</li>
<li>应用特性<br>软件的应用极为广泛，如今它已渗入国民经济和国防的各个领域，现已成为信息产业、先进制造业和服务业的核心，占据了无可取代的地位</li>
</ol>
<h3 id="软件的分类"><a href="#软件的分类" class="headerlink" title="软件的分类"></a>软件的分类</h3><ol>
<li>系统软件<br>系统软件是负责管理计算机系统中各种独立的硬件，使得它们可以协调工作<ul>
<li>服务型程序：如诊断程序、排错程序、练习程序等</li>
<li>语言程序：如汇编程序、编译程序、解释程序</li>
<li>操作系统</li>
<li>数据库管理系统</li>
</ul>
</li>
<li>应用软件<br>应用系统是为了某种特定的用途而被开发的软件，它可以是一个特定的程序，比如一个图像浏览器，也可以是一组功能联系紧密，可以互相协作的程序的集合</li>
</ol>
<h3 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h3><p>软件的生命周期，又称为软件的生存周期。它是按开发软件的规模和复杂程度，从时间上把软件开发的整个过程（从计划开发开始到软件报废为止的整个历史阶段）进行分解，形成相对独立的几个阶段<br>每个阶段又分解成几个具体的任务，然后按规定顺序依次完成各阶段的任务并规定一套标准的文档作为各个阶段的开发成果，最后生产出高质量的软件</p>
<h3 id="软件的一生"><a href="#软件的一生" class="headerlink" title="软件的一生"></a>软件的一生</h3><p>问题定义 -&gt; 可行性研究 -&gt; 需求分析 -&gt; 概要设计 -&gt; 详细设计 -&gt; 编码和单元测试 -&gt; 综合测试 -&gt; 软件维护</p>
<p>e.g. 余额宝的诞生</p>
<p>问题定义：普惠金融与互联网金融的融合 -&gt; 可行性研究：T+0是否可以实现；是否合规 -&gt; 需求分析：细分 story -&gt; 概要设计 -&gt; 详细设计 -&gt; 编码和单元测试 -&gt; 综合测试 -&gt; 软件维护</p>
<h3 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h3><p>由于项目、需求的模式不同，所以在软件生命周期过程中选择的软件开发模型也会有所不同，在历史上，软件开发模型经历了“边做边改”、瀑布、原型、螺旋、敏捷等模式的变更</p>
<ul>
<li><p>瀑布模型<br>计划 -&gt; 需求分析 -&gt; 设计 -&gt; 编码 -&gt; 测试 -&gt; 运行维护</p>
<p>特点：</p>
<ol>
<li>软件开发的各项活动严格按照线性方式进行</li>
<li>当前活动接受上一项活动的工作结果</li>
</ol>
<p>缺点：</p>
<ol>
<li>由于开发模型是线性的，增加了开发的风险</li>
<li>早期的错误可能要等到开发后期的阶段才能发现</li>
</ol>
</li>
<li><p>原型模型<br>客户与开发公司紧密联系，开发周期长。开发会受到需求变更的影响</p>
<p>特点：</p>
<ol>
<li>实现客户与系统的交互</li>
<li>进一步细化待开发软件需求</li>
<li>开发人员可以确定客户的真正需求是什么</li>
</ol>
</li>
<li><p>螺旋模型<br>制定计划 -&gt; 风险分析 -&gt; 实施工程（需求确认、软件需求、软件产品设计、设计确认与认证、详细设计、开发、测试） -&gt; 客户评估</p>
<p>特点：</p>
<ol>
<li>螺旋模型是将瀑布模型与快速原型模型结合起来</li>
<li>强调了其他模型所忽视的风险分析</li>
<li>每一次螺旋包括4个步骤：制定计划、风险分析、实施工程、客户评估</li>
</ol>
<p>缺点：</p>
<ol>
<li>强调风险分析，但要求许多客户接受并相信这种分析，是不容易的</li>
</ol>
</li>
<li><p>敏捷模型<br>敏捷开发是一种以人为核心、迭代、循序渐进的开发方法</p>
<p>特点：</p>
<ol>
<li>短周期开发</li>
<li>增量开发</li>
<li>由程序员和测试人员编写的自动化测试来监控开发进度</li>
<li>通过口头沟通、测试和源代码来交流系统的结构和意图</li>
<li>编写代码之前先写测试代码，也叫做测试先行</li>
</ol>
<p>缺点：</p>
<ol>
<li>团队的组建较难，人员素质要求较高</li>
<li>对测试员要求完全掌握各种脚本语言编程，能执行单元测试、自动化测试</li>
</ol>
</li>
</ul>
<h3 id="软件开发文档–学会写测试文档"><a href="#软件开发文档–学会写测试文档" class="headerlink" title="软件开发文档–学会写测试文档"></a>软件开发文档–学会写测试文档</h3><p>需求分析文档 -&gt; 概要设计文档 -&gt; 详细设计文档 -&gt; 测试设计文档 -&gt; 测试用例 -&gt; 测试报告</p>
<h3 id="项目进程"><a href="#项目进程" class="headerlink" title="项目进程"></a>项目进程</h3><ul>
<li>编程阶段-单元（白盒）<br>测试参与</li>
<li>编程完成-开发联调（集成测试）<br>开发为主</li>
<li>提测-冒烟测试（自动化为主，手工为辅）<br>测试执行</li>
<li>测试阶段-系统测试（黑盒功能测试为主，自动化&#x2F;接口测试为辅，根据项目进行性能、安全测试）</li>
<li>验收阶段-验收测试<br>测试配合用户或需求</li>
</ul>
<h3 id="软件测试概念"><a href="#软件测试概念" class="headerlink" title="软件测试概念"></a>软件测试概念</h3><ul>
<li>经典定义：<br>软件测试（Software Testing），在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程</li>
<li>标准定义：<br>软件测试是使用人工或自动的手段来运行或测定某个软件系统的过程，其目的是在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别</li>
<li>软件测试目的：<br>软件测试目的在于发现问题，检查系统是否满足需求</li>
</ul>
<h3 id="软件测试方法和分类"><a href="#软件测试方法和分类" class="headerlink" title="软件测试方法和分类"></a>软件测试方法和分类</h3><ul>
<li>软件测试分类<ul>
<li>按生命周期划分<ul>
<li>单元测试</li>
<li>冒烟测试</li>
<li>集成测试</li>
<li>系统测试</li>
<li>验收测试</li>
</ul>
</li>
<li>按测试方法划分<ul>
<li>白盒测试<ul>
<li>静态分析</li>
<li>动态分析<ul>
<li>逻辑覆盖测试<ul>
<li>语句覆盖</li>
<li>判定覆盖</li>
<li>条件覆盖</li>
<li>路径覆盖</li>
</ul>
</li>
<li>插桩测试</li>
</ul>
</li>
</ul>
</li>
<li>黑盒测试<ul>
<li>功能测试<ul>
<li>界面测试</li>
<li>冒烟测试</li>
<li>回归测试</li>
<li>业务测试</li>
<li>兼容性测试</li>
<li>易用性测试</li>
</ul>
</li>
<li>自动化测试<ul>
<li>WEB自动化测试</li>
<li>接口自动化测试</li>
</ul>
</li>
<li>性能测试<ul>
<li>性能测试</li>
<li>负载测试</li>
<li>压力测试</li>
<li>容量测试</li>
<li>并发测试</li>
<li>持久性测试</li>
</ul>
</li>
<li>安全测试<ul>
<li>手动操作</li>
<li>自动化审计</li>
</ul>
</li>
</ul>
</li>
<li>灰盒测试</li>
</ul>
</li>
<li>其他<ul>
<li>随机测试</li>
<li>探索性测试</li>
<li>α测试</li>
<li>β测试</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="性能测试的细分问题"><a href="#性能测试的细分问题" class="headerlink" title="性能测试的细分问题"></a>性能测试的细分问题</h3><ol>
<li>性能测试：性能测试通常泛指所有类型的性能测试，目标是在特定条件下验证软件系统的性能是否达到预期指标的结果。</li>
<li>负载测试：负载测试是指模拟真实的用户行为，通过不断加压直到系统性能测试瓶颈或资源达到饱和。负载测试是最常进行的性能测试，用于测量系统的容量，发现系统瓶颈并配合性能调优。</li>
<li>压力测试：压力测试是指测试系统在一定的饱和状态下系统的处理能力。在负载测试的基础上，继续不断加压到一定阶段。通过压力测试通过CPU使用率达到75%以上或者内存使用率达70%以上（具体的压力指标也可以是数据库达到相关指标，或者中间件连接数达到某种指标等等），用于测试系统在压力环境下的稳定性。<br>注：许多开发人员提出测试申请，说要做一个压力测试，做为专业的性能测试人员，那么需要明确测试需求，开发人员说的压力测试，往往不是真正意义上的压力测试</li>
<li>可靠性测试：可靠性测试是指加载一定的业务压力，同时让压力持续运行一段时间，测试系统是否可以稳定运行。</li>
<li>并发测试：并发测试是模拟用户在访问同一应用的测试，用于发现并发问题，例如线程锁、资源争用、数据库死锁等。</li>
<li>配置测试：配置测试是指验证各种配置对系统性能的影响，常用于性能调优和能力规划。</li>
<li>疲劳强度测试：在系统稳定运行情况下，以能够支持的最大并发用户数或日常运行用户数，持续执行业务操作一段时间，通过综合分析交易执行指标和资源监控指标，来确定系统处理最大工作强度的性能表现。</li>
<li>大数据量测试：大数据量测试侧重点在于数据的量上，包括独立的数据量测试和综合数据量测试。独立的数据量测试可以理解为某些系统存储、传输、统计、查询等业务进行大数据量测试，而综合数据量测试一般和压力测试、负载测试、疲劳强度测试相结合进行。</li>
</ol>
<h3 id="生命周期各测试方法对比"><a href="#生命周期各测试方法对比" class="headerlink" title="生命周期各测试方法对比"></a>生命周期各测试方法对比</h3><table>
<thead>
<tr>
<th></th>
<th>单元测试</th>
<th>集成测试</th>
<th>冒烟测试</th>
<th>系统测试</th>
<th>验收测试</th>
</tr>
</thead>
<tbody><tr>
<td>测试阶段</td>
<td>编码后</td>
<td>单元测试完成后</td>
<td>提测后</td>
<td>冒烟测试通过后</td>
<td>发布前</td>
</tr>
<tr>
<td>测试对象</td>
<td>最小模块</td>
<td>模块间的接口</td>
<td>整个系统</td>
<td>整个系统</td>
<td>整个系统</td>
</tr>
<tr>
<td>测试人员</td>
<td>白盒测试或开发</td>
<td>白盒测试或开发</td>
<td>黑盒测试</td>
<td>黑盒测试</td>
<td>最终用户或需求方</td>
</tr>
<tr>
<td>测试依据</td>
<td>代码、注释、详细设计文档</td>
<td>单元测试模块、概要设计模块</td>
<td>冒烟测试用例</td>
<td>需求说明文档、测试方案、测试用例</td>
<td>用户需求、验收标准</td>
</tr>
<tr>
<td>测试方法</td>
<td>白盒测试</td>
<td>黑盒与白盒结合</td>
<td>黑盒测试（手工或与自动化结合）</td>
<td>黑盒测试</td>
<td>黑盒测试</td>
</tr>
</tbody></table>
<h3 id="软件测试常见术语"><a href="#软件测试常见术语" class="headerlink" title="软件测试常见术语"></a>软件测试常见术语</h3><ul>
<li>缺陷(Bug&#x2F;Defect)<br>软件的Bug指的是软件中（包括程序和文档）不符合用户需求的问题</li>
<li>测试环境<br>软件测试环境就是软件运行的平台，包括软件、硬件和网络的集合，用一个等式来表示： 测试环境&#x3D;软件+硬件+网络</li>
<li>测试用例(Test Case)<br>在测试执行之前设计的一套详细的测试方案，包括测试环境、测试步骤、测试数据和预期结果<br>用一个等式来简单表示：测试用例&#x3D;输入+输出+测试环境<br>其中，“输入”包括测试数据和操作步骤，“输出”指的是期望结果，“测试环境”指的是系统环境设置</li>
<li>冒烟测试(Smoke Testing)<br>在对一个新版本进行系统大规模地测试之前，先验证一下软件的基本功能是否实现，是否具备可测性</li>
<li>α测试<br>验收测试的一种，指的是由用户、测试人员、开发人员等共同参与的内部测试</li>
<li>β测试<br>验收测试的一种，指的是内测后的公测，即完全交给最终用户测试</li>
</ul>
<h3 id="软件测试常见模型"><a href="#软件测试常见模型" class="headerlink" title="软件测试常见模型"></a>软件测试常见模型</h3><ul>
<li><p>V模型<br>V模型是我们熟知的瀑布模型的一种改进，瀑布模型将软件生命周期划分为计划、分析、设计、编码、测试和维护六个阶段，由于前期的错误可能要等到开发后期的测试阶阶段才能发现，所以可能带来严重的后果<br>V模型就是在这点改进了瀑布模型，在软件开发的生存期，开发活动和测试活动几乎同时开始，这两个并行的动态的过程就会极大的减少bug和error出现的几率</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/37547176b8fa48c098f21584de30de0e.png" alt="在这里插入图片描述"></p>
</li>
<li><p>W模型<br>一些高性能高风险的系统、互联网软件，或一个系统难以被具体模块化的时候，就比较难做成V模式所需的各种构建，需要更强调迭代的开发模型或者敏捷开发模型<br>W模型从V模型演化过来，实际上开发是V，测试是并行的V；相对于V模型，W模型增加了软件各开发阶段中应同步进行的验证和确认活动，W明确表示出了测试与开发的并行关系。测试与开发是同步进行的，有利于尽早地全面地发现问题</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/b32ad05581ab47a1b6f9e24d8308a6e5.png" alt="在这里插入图片描述"></p>
</li>
<li><p>H模型<br>真正的测试级别之间不存在严格的次序关系，各阶段间可以反复出发、迭代、增量<br>为了解决V模型和W模型存在的问题，有专家提出了H模型。它将测试活动完全独立出来，形成一个完全独立的流程，将测试准备活动和测试执行活动清晰地体现出来</p>
</li>
<li><p>X模型<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/000381b057c547d4bafe51114795b42c.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="软件测试覆盖率"><a href="#软件测试覆盖率" class="headerlink" title="软件测试覆盖率"></a>软件测试覆盖率</h3><ul>
<li><p>测试覆盖率<br>覆盖率是用来度量测试完整性的一个手段，同时也是测试技术有效性的一个度量<br>覆盖率 &#x3D; （至少被执行一次的item数）&#x2F;item的总数</p>
<p>特点：</p>
<ol>
<li>通过覆盖率数据，可以检测我们的测试是否充分</li>
<li>分析出测试的弱点在哪方面</li>
<li>指导我们设计能够增加覆盖率的测试用例，有效提高测试质量，但是测试用例设计不能一味追求覆盖率，因为测试成本随覆盖率的增加而增加</li>
</ol>
<p>测试覆盖率对于黑盒测试来说，主要指两个方面： 需求覆盖 和 用例覆盖</p>
<ul>
<li>需求覆盖<ol>
<li>定义：它表示在测试中，有哪些函数被测试到了，其被测试到的频率有多大，这些函数在系统所有函数中占的比例有多大通过设计一定的测试用例，要求每个需求点都被测试到</li>
<li>计算公式：需求覆盖 &#x3D; （被验证到的需求数量）&#x2F;（总的需求总数）</li>
</ol>
</li>
<li>用例覆盖<ol>
<li>定义：主要体现在我们每轮测测试验证通过的用例在总用例中的比重</li>
<li>计算公式：用例覆盖 &#x3D; （验证通过的用例数量）&#x2F;（总的用例总数）</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="测试覆盖率的运用"><a href="#测试覆盖率的运用" class="headerlink" title="测试覆盖率的运用"></a>测试覆盖率的运用</h3><ul>
<li>简单的测试覆盖率<br>本次测试执行的用例数&#x2F;所有用例数<br>上述覆盖率统计建立在认为总用例数编写全面，一般对于大型系统要求覆盖率100%<br>覆盖率的审核：抽样验收</li>
<li>基于产品的测试覆盖率<br>已测试需求点&#x2F;设计所有需求数<br>以产品、需求维度统计，无论大型项目或是小需求迭代都要求覆盖率达到100%<br>覆盖率的审核：抽样验收</li>
<li>基于白盒的测试覆盖率<br>大多工具判断语句覆盖，即单元测试代码覆盖代码行&#x2F;总代码行<br>更多考察研发人员；更多时候要求覆盖率达到80+%<br>缺陷：覆盖率数据只能代表测试过哪些代码，不能代表是否测试好哪些代码；容易遗漏逻辑、判断等场景</li>
<li>基于自动化的测试覆盖率<br>自动化覆盖的测试场景（测试用例）&#x2F;所有测试场景（用例）<br>80&#x2F;20原则，比如用户80%的时间在使用20%的功能，20%的功能就可以支撑起用户最关键的业务场景，自动化测试的用例选择更注重于这20%的核心功能<br>用途：自动化测试更着重于回归验证，没必要追求过高的覆盖率，而要考虑用例设计</li>
</ul>
<h3 id="测试覆盖率的最终意义"><a href="#测试覆盖率的最终意义" class="headerlink" title="测试覆盖率的最终意义"></a>测试覆盖率的最终意义</h3><p>应用最多的地方在测试停止标准</p>
<p>单纯讨论测试覆盖率，在瀑布式开发模型中并不重要，但在螺旋式、敏捷开发模型中由于不断迭代累加，很难确定哪些模块在开发过程中没有给予足够的测试</p>
<p>在短迭代、DevOps中，更强调用单元测试覆盖率来评估不断增加的代码数量</p>
<h3 id="理解测试覆盖率"><a href="#理解测试覆盖率" class="headerlink" title="理解测试覆盖率"></a>理解测试覆盖率</h3><p>我们学习了测试覆盖率的两种统计方式，一种是需求覆盖率，一种是需求覆盖率，那你是怎么理解这两种覆盖率之间的联系的？比如说：是根据不同的覆盖率规则，来设计不同维度的测试用例么？还是根据不同的需求，选择性的进行测试？或者？</p>
<p>这是我们统计的两种方式，跟我们设计用例没有关系，是统计执行的。</p>
<p>可以这么来理解，我们假设这次项目有100个需求，你根据需求设计了5000条用例，执行了4800条用例，覆盖了99个需求。</p>
<p>那么需求覆盖率就是99%，用例覆盖率就是96%。</p>
<p>测试的工作内容没有变化，只是统计方式有差别。</p>
<h3 id="软件测试人员需要的知识体系"><a href="#软件测试人员需要的知识体系" class="headerlink" title="软件测试人员需要的知识体系"></a>软件测试人员需要的知识体系</h3><ul>
<li>软件测试基础知识</li>
<li>软件测试流程</li>
<li>测试用例设计方法</li>
<li>兼容性测试&#x2F;易用性测试</li>
<li>缺陷管理</li>
<li>测试工具使用</li>
<li>测试文档编写</li>
<li>……</li>
</ul>
<h3 id="软件测试人员具备的素质"><a href="#软件测试人员具备的素质" class="headerlink" title="软件测试人员具备的素质"></a>软件测试人员具备的素质</h3><ul>
<li>踏实细心</li>
<li>积极主动</li>
<li>好奇心，怀疑一切</li>
<li>良好交流能力</li>
<li>自我提高和总结能力</li>
<li>责任感</li>
<li>……</li>
</ul>
<h3 id="软件测试的原则"><a href="#软件测试的原则" class="headerlink" title="软件测试的原则"></a>软件测试的原则</h3><ul>
<li>所有的测试都应追溯到用户需求<br>“产品缺陷的80%以上是产品开发过程中的需求定义阶段引入的，如果需求得到了准确的验证，则可以消除80%的返工问题，节省总项目投入费用的45%”</li>
<li>尽早启动测试工作</li>
<li>Pareto法则应用于软件测试<br>Pareto法则是由意大利经济学家Pareto提出的，又称为28效率法则<br>测试中的Pareto法则是说一般情况下，在分析、设计、实现阶段的复审和测试工作能够发现和避免80%的缺陷，而系统测试又能找出其余缺陷中的80%，最后4%的缺陷可能只有在用户的大范围、长时间使用后才会暴露出来</li>
<li>穷尽测试是不可能的<br>由于很少有机会对一个应用软件进行所有可能的测试，对大多数软件开发项目来说，利用风险分析是适当的。这需要判断技能、常识、感觉和经验。如果有正当理由，也可采用正式的方法</li>
<li>杀虫剂怪事<br>软件测试越多，其对测试的免疫力越强的现象<br>为了克服杀虫剂怪事，软件测试员必须不断编写不同的、新的测试程序，对程序的不同部分进行测试，以找出更多软件缺陷</li>
<li>前进两步，后退一步<br>测试中的一个基本问题是–缺陷修复总会以（20-50）%的几率引入新的缺陷</li>
<li>三心二意<br>细心、信心、耐心<br>团队合作的沟通意识、时刻保持怀疑的态度且有缺陷预防意识</li>
</ul>
<h2 id="软件测试流程"><a href="#软件测试流程" class="headerlink" title="软件测试流程"></a>软件测试流程</h2><h3 id="软件测试环境搭建原则"><a href="#软件测试环境搭建原则" class="headerlink" title="软件测试环境搭建原则"></a>软件测试环境搭建原则</h3><ul>
<li>搭建测试环境前<ul>
<li>确定测试目的<ul>
<li>功能测试，稳定性测试，还是性能测试，测试目的不同，搭建测试环境时应注意的点也不同</li>
<li>功能测试：不需要大量的数据，需要覆盖率高，测试数据要求尽量真实</li>
<li>性能测试：可能需要大量存量数据或者与实际硬件环境尽可能相似的硬件配置</li>
</ul>
</li>
<li>测试的软件环境尽可能的模拟真实环境<ul>
<li>尽可能地模拟用户使用环境，选用合适的操作系统和软件平台</li>
<li>了解符合测试软件运行的最低要求及用户使用的硬件配置</li>
<li>了解用户常用的软件，避免所有配置所有操作系统下都要进行测试，没有侧重点，浪费时间</li>
<li>产品化的测试则需要考虑兼容性的方案</li>
</ul>
</li>
<li>营造独立的测试环境<ul>
<li>不同的项目、不同的公司会对测试环境的独立性有不同的要求</li>
<li>测试过程中尽量保证测试环境独立，不受其他测试人员以及项目研发人员的影响</li>
</ul>
</li>
<li>构建可复用的测试环境<ul>
<li>通过备份或数据隔离的方式</li>
<li>重复运用一套测试环境进行多版本多时间段的测试</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="搭建测试环境过程分析"><a href="#搭建测试环境过程分析" class="headerlink" title="搭建测试环境过程分析"></a>搭建测试环境过程分析</h3><ul>
<li>线下搭建<ul>
<li>独立测试服务器或虚拟机</li>
<li>测试环境配置</li>
<li>测试项目导入</li>
</ul>
</li>
</ul>
<h3 id="测试环境配置"><a href="#测试环境配置" class="headerlink" title="测试环境配置"></a>测试环境配置</h3><ul>
<li>配置java环境（下载jdk并配置环境变量）</li>
<li>下载并安装中间件（tomcat、jetty或其他）</li>
<li>安装数据库并导入初始化脚本</li>
</ul>
<h3 id="Docker模式"><a href="#Docker模式" class="headerlink" title="Docker模式"></a>Docker模式</h3><ul>
<li>构建属于自己的image</li>
<li>一键deploy</li>
</ul>
<h3 id="依赖第三方平台"><a href="#依赖第三方平台" class="headerlink" title="依赖第三方平台"></a>依赖第三方平台</h3><ul>
<li>依赖第三方平台（如蚂蚁金融云）</li>
</ul>
<h3 id="浅谈测试环境的建设落地"><a href="#浅谈测试环境的建设落地" class="headerlink" title="浅谈测试环境的建设落地"></a>浅谈测试环境的建设落地</h3><h4 id="环境建设思路"><a href="#环境建设思路" class="headerlink" title="环境建设思路"></a>环境建设思路</h4><ul>
<li>考虑点：用途、使用成本、维护成本</li>
<li>基本架构<ul>
<li>研发环境：用于研发自测、集成测试</li>
<li>测试环境：用于日常单系统或两两微服务之间测试，可同时集成自动化测试回归</li>
<li>联测环境：完备环境，用于大型联测</li>
<li>外联环境（如果有需求）：稳定版本环境，用于外部商户等联调</li>
<li>灰度&#x2F;沙箱环境：用于生存数据测试，仿真测试</li>
</ul>
</li>
</ul>
<h4 id="简单的测试过程"><a href="#简单的测试过程" class="headerlink" title="简单的测试过程"></a>简单的测试过程</h4><p>制定测试计划 -&gt; 设计测试用例 -&gt; 执行测试 -&gt; 提交测试发现的问题 -&gt; 所有问题已修复 -&gt; 结束</p>
<h4 id="测试过程划分"><a href="#测试过程划分" class="headerlink" title="测试过程划分"></a>测试过程划分</h4><p>策划（需求&amp;计划） -&gt; 设计 -&gt; 执行 -&gt; 评估 -&gt; 总结</p>
<ul>
<li>在逻辑上，测试活动是按顺序进行的</li>
<li>在实际测试过程中，这些活动是可以重叠或同时进行的</li>
</ul>
<h3 id="测试策划过程"><a href="#测试策划过程" class="headerlink" title="测试策划过程"></a>测试策划过程</h3><ul>
<li>进行测试需求的分析</li>
<li>确定需要测试的内容或质量特征</li>
<li>明确测试的充分性要求</li>
<li>提出测试的基本方法</li>
<li>确定测试的资源和技术需求</li>
<li>进行风险分析与评估</li>
<li>根据上述分析结果制定测试计划</li>
<li>根据测试计划开展相应的测试控制活动</li>
</ul>
<h3 id="需求测试"><a href="#需求测试" class="headerlink" title="需求测试"></a>需求测试</h3><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ul>
<li>过往的软件生命周期中，需求分析阶段是没有测试人员参与的</li>
<li>但随着软件过程的优化，测试人员的加入对需求分析阶段有了更大的作用</li>
<li>测试工程师参与需求分析，对需求了解很深刻，减少与开发人员的交互，节省时间</li>
<li>早期确定测试用例的编写思路，为测试打好了基础</li>
<li>可以获取一些测试数据，为测试用例设计提供帮助</li>
<li>可以发现需求不合理的地方，降低测试成本</li>
</ul>
<h4 id="需求测试的作用"><a href="#需求测试的作用" class="headerlink" title="需求测试的作用"></a>需求测试的作用</h4><ul>
<li><p>测试需求的分析用来确定整个测试工作，明确测试对象以及测试工作的范围和作用，并作为测试覆盖的基础</p>
</li>
<li><p>被确定的测试需求项必须是可核实的，测试需求必须有一个可观察、可评测的结果</p>
</li>
<li><p>如果无法核实的需求就不是测试需求</p>
</li>
<li><p>测试需求分析还包括与客户的交流以澄清某些混淆</p>
</li>
<li><p>明确哪些需求更重要</p>
</li>
<li><p>确保风险承担着尽早地对项目达成共识</p>
</li>
<li><p>并对将来的产品有个清晰的认识</p>
</li>
<li><p>测试需求是制定测试计划的基本依据</p>
</li>
<li><p>测试需求是设计测试用例的指导</p>
</li>
<li><p>确定了要测什么、测哪些方面才能有效设计用例</p>
</li>
</ul>
<h4 id="需求验证"><a href="#需求验证" class="headerlink" title="需求验证"></a>需求验证</h4><ul>
<li>审查需求文档<ul>
<li>对需求文档及相关模型进行仔细检查</li>
<li>另外在需求开发期间所作的非正式评审也是有所裨益的</li>
</ul>
</li>
<li>以需求为依据编写测试用例<ul>
<li>编写用户手册</li>
<li>在需求开发早期即可起草一份浅显易懂的用户手册，用以描述出所有对用户可见的功能并用它作为需求规格说明的参考并辅助需求分析</li>
</ul>
</li>
<li>确定合格的标准<ul>
<li>让用户描述什么样的产品才算满足他们的要求和适合他们的使用</li>
<li>将确认合格的测试建立在使用场景描述或使用实例的基础之上</li>
</ul>
</li>
</ul>
<h4 id="需求规格说明书检查列表"><a href="#需求规格说明书检查列表" class="headerlink" title="需求规格说明书检查列表"></a>需求规格说明书检查列表</h4><table>
<thead>
<tr>
<th>序号</th>
<th>检查项</th>
<th>检查结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>用户覆盖了用户提出的所有需求项</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>用词是否清晰，语义是否存在有歧义的地方</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>是否清楚地描述了软件需要做什么以及不做什么</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>是否描述了软件的目标环境</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>是否对需求项进行了合理的编号</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>需求项是否前后一致、彼此不冲突</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>是否清楚地说明了系统的每个输入、输出格式，以及输入与输出之间的对应关系</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>是否清晰地描述了软件系统的性能要求</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>需求的优先级是否合理分配</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>是否描述了各种约束条件</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
</tbody></table>
<h3 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h3><h4 id="测试前的思考"><a href="#测试前的思考" class="headerlink" title="测试前的思考"></a>测试前的思考</h4><ul>
<li>你知道要测试的系统是干什么的吗？</li>
<li>你了解系统有哪些特点吗？</li>
<li>系统有些什么功能？</li>
<li>系统哪些部分需要测试？哪些不要测试？</li>
<li>系统对性能有什么要求？</li>
<li>系统对安全性有什么要求？</li>
<li>……</li>
</ul>
<h4 id="测试策略是什么"><a href="#测试策略是什么" class="headerlink" title="测试策略是什么"></a>测试策略是什么</h4><ul>
<li>测试策略是描述测试项目和测试任务之间的关系</li>
<li>它用来说明要测什么，如何测，如何协调测试资源和测试时间等</li>
<li>测试策略制定得是否合理高效会对测试项的进度产生很大的影响</li>
</ul>
<h4 id="测试策略要素"><a href="#测试策略要素" class="headerlink" title="测试策略要素"></a>测试策略要素</h4><p>测试安排发布计划 -&gt; 测试范围 -&gt; 测试资源 -&gt; 测试环境 -&gt; 测试方法 -&gt; 用例设计方法 -&gt; 文档管理 -&gt; 风险管理 -&gt; 上线跟踪验证</p>
<ul>
<li>测试安排、发布计划<ul>
<li>罗列测试项目本身重要的里程碑</li>
<li>每个里程碑都需要有明确的结束时间</li>
<li>这个时间可以指导我们后续的测试</li>
<li>如果测试时间安排不足，我们就可以在后续的测试范围中挑选优先级比较高的特性来执行测试</li>
<li>这样可以最大程度的保证产品的质量</li>
</ul>
</li>
<li>测试范围（按优先级排列）<ul>
<li>分为In Scope和Out Of Scope</li>
<li>需要说明哪些模块是在测试范围中的，哪些是本阶段测试不考虑的</li>
<li>对于在测试范围中的模块，需要给出优先级</li>
<li>以便相应测试时间不足的情况</li>
<li>对于不在测试范围中的模块，需要给出原因</li>
<li>为什么在本测试阶段不考虑测</li>
</ul>
</li>
<li>测试资源<ul>
<li>测试资源在测试策略中也是很重要的一环，它分为人力和工具两部分</li>
<li>人力资源主要是参与测试的人员，当然可以包括很多的角色，如专业测试人员，客户，产品经理等</li>
<li>工具主要是指可能用到的其他软件</li>
</ul>
</li>
<li>测试环境<ul>
<li>测试环境主要包括推荐环境解决方案，操作系统要求，软硬件要求</li>
<li>对于推荐解决方案，需要陈述的是对测试项目、对其他软件的依赖</li>
<li>比如测试项目对Java有依赖，推荐版本可能就是1.7</li>
</ul>
</li>
<li>测试方法<ul>
<li>测试方法的罗列主要是为了说明针对测试项目我们要开展哪些类型的测试</li>
<li>功能测试是必须的，非功能测试是可选的</li>
</ul>
</li>
<li>文档管理<ul>
<li>对于一个完整的产品来说，文档是很重要的一环</li>
<li>它一般包括安装、升级文档，用户指南等</li>
<li>文档不单单是一个文件</li>
<li>它需要经过完整的测试才能发布给用户</li>
<li>差的文档很可能会误导用户，从而使他们对测试项目失去信心</li>
</ul>
</li>
<li>风险管理<ul>
<li>风险管理模块需要罗列出来现在已知的可能会出现不确定性的因素</li>
<li>这些因素可能来自技术，资源或者其他方面的</li>
</ul>
</li>
</ul>
<h3 id="测试计划与测试方案"><a href="#测试计划与测试方案" class="headerlink" title="测试计划与测试方案"></a>测试计划与测试方案</h3><ul>
<li><strong>测试策略</strong>：侧重需求分析，评估风险，定义测试范围<ul>
<li>确定测试方法，制定测试启动、停止、完成标准和条件</li>
</ul>
</li>
<li><strong>测试计划</strong>：制定项目测试过程中的测试重点<ul>
<li>各个阶段的任务分配以及时间进度安排</li>
<li>并提出对各项任务的评估，风险分析，可以包括测试策略</li>
</ul>
</li>
<li><strong>测试方案</strong>：侧重测试的方法，测试环境的规划<ul>
<li>测试工具的设计和选择，测试用例的设计方法，测试代码的设计方案</li>
</ul>
</li>
</ul>
<h4 id="测试策略-vs-测试计划-vs-测试方案"><a href="#测试策略-vs-测试计划-vs-测试方案" class="headerlink" title="测试策略 vs 测试计划 vs 测试方案"></a>测试策略 vs 测试计划 vs 测试方案</h4><ul>
<li>实际实施过程中；往往存在这样类似的方式</li>
<li>测试方案 &#x3D; 测试计划 + 用例设计方案 + 工具选择 + 自动化&#x2F;性能测试具体方案</li>
<li>测试计划 &#x3D; 测试策略 + 测试任务分配 + 时间进度安排</li>
</ul>
<h4 id="测试方案列表"><a href="#测试方案列表" class="headerlink" title="测试方案列表"></a>测试方案列表</h4><ul>
<li>1 需求说明<ul>
<li>1.1 需求汇总</li>
<li>1.2 需求变更</li>
</ul>
</li>
<li>2 总体计划安排和负责人<ul>
<li>2.1 测试计划进度表</li>
</ul>
</li>
<li>3 测试方案<ul>
<li>3.1 测试重点</li>
<li>3.2 联测方案</li>
<li>3.3 测试策略方法</li>
<li>3.4 测试工具平台</li>
</ul>
</li>
<li>4 环境搭建部署及数据准备<ul>
<li>4.1 环境拓扑</li>
<li>4.2 应用部署</li>
<li>4.3 数据准备</li>
</ul>
</li>
<li>5 测试执行计划<ul>
<li>5.1 测试计划</li>
<li>5.2 正向用例</li>
<li>5.3 反向用例</li>
<li>5.4 用例评审</li>
</ul>
</li>
<li>6 测试工单<ul>
<li>6.1 冒烟工单</li>
<li>6.2 单测工单</li>
<li>6.3 联测工单</li>
<li>6.4 预发布验证工单</li>
<li>6.5 灰度验证工单</li>
<li>6.6 线上验证工单</li>
</ul>
</li>
<li>7 测试限制及无法测试功能列表</li>
<li>8 测试情况日汇总&amp;风险点、待确认列表<ul>
<li>8.1 每日测试情况及风险点</li>
</ul>
</li>
</ul>
<h3 id="测试方案评审"><a href="#测试方案评审" class="headerlink" title="测试方案评审"></a>测试方案评审</h3><p>目前，开发有需求说明会、设计评审会、代码复审会等各种会议，但多是站在开发的角度，从需求和代码层面进行复审和风险规避，在测试环节和测试阶段缺少以测试为主体的评审机制和沟通机制</p>
<p>容易造成以下几方面问题：</p>
<ul>
<li><p>仅从文档、沟通获取信息，可能会造成信息不对称，认识片面，理解错误或不深入等问题</p>
</li>
<li><p>缺少同行交叉评审和开发评审机制，无法充分发挥集体智慧，个人的思维难以突破，可能会出现测试遗漏的情况</p>
</li>
<li><p>评审目的</p>
<ul>
<li>呈现测试的工作</li>
<li>与开发达成共识</li>
<li>不同的思维方式碰撞出火花，借鉴别人的思考方式</li>
<li>培养这样的行为模式：愿意为团队或他人出谋划策</li>
<li>发挥团队协作，最大限度发挥个人的经验，特长，实现技能互补</li>
</ul>
</li>
<li><p>评审重点</p>
<ul>
<li>采用的测试方法</li>
<li>等价类划分的依据</li>
<li>测试数据的选取和准备方法</li>
<li>流程测试的路径组合</li>
<li>数据比对选取的对象和数据检查点</li>
<li>是否需要模拟数据及模拟数据的方法</li>
<li>基于风险的测试取舍</li>
</ul>
</li>
</ul>
<h2 id="软件测试设计"><a href="#软件测试设计" class="headerlink" title="软件测试设计"></a>软件测试设计</h2><h3 id="测试设计"><a href="#测试设计" class="headerlink" title="测试设计"></a>测试设计</h3><p>测试设计是将概括的测试目标转化为具体的测试条件和测试用例的一系列活动</p>
<h4 id="测试分析和设计的主要任务"><a href="#测试分析和设计的主要任务" class="headerlink" title="测试分析和设计的主要任务"></a>测试分析和设计的主要任务</h4><ul>
<li>评审测试依据（需求，系统架构、设计和接口说明）</li>
<li>评估设计依据和测试对象的可靠性</li>
<li>通过对测试项、规格说明、测试对象行为和结构的分析，识别测试条件并确定优先级</li>
<li>设计测试用例，并确定优先级</li>
<li>确定测试条件和测试用例所需的必要的测试数据</li>
</ul>
<h4 id="确定测试条件"><a href="#确定测试条件" class="headerlink" title="确定测试条件"></a>确定测试条件</h4><ul>
<li>依据在测试策略或测试计划中确定的测试技术</li>
<li>通过对测试依据和测试目标的分析，可以确定需要测试的内容，获得测试条件</li>
</ul>
<h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><ul>
<li>测试用例是通过使用在测试计划中确定的测试技术，对于已确定的测试条件进行逐步推敲，精炼而设计出来的重点说明如何具体操作产生何种结果的文档</li>
<li>测试用例应该具有可重复性、可验证性和需求可追踪性</li>
</ul>
<h4 id="测试用例设计包括以下关键点"><a href="#测试用例设计包括以下关键点" class="headerlink" title="测试用例设计包括以下关键点"></a>测试用例设计包括以下关键点</h4><ul>
<li>前提条件，如项目或局部测试环境的需求，及其交付计划</li>
<li>测试步骤</li>
<li>测试数据</li>
<li>预期结果</li>
</ul>
<h4 id="测试用例案例"><a href="#测试用例案例" class="headerlink" title="测试用例案例"></a>测试用例案例</h4><table>
<thead>
<tr>
<th>序号</th>
<th>模块名称</th>
<th>测试子项</th>
<th>用例名称（测试意图）</th>
<th>用例级别</th>
<th>预置条件</th>
<th>测试步骤</th>
<th>预期结果</th>
<th>测试结果</th>
<th>缺陷编号</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="测试用例常用设计方法"><a href="#测试用例常用设计方法" class="headerlink" title="测试用例常用设计方法"></a>测试用例常用设计方法</h4><ul>
<li>等价类划分法</li>
<li>边界值法</li>
<li>因果图设计法</li>
<li>判定表设计法</li>
<li>正交实验法</li>
</ul>
<h3 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h3><p>等价类划分的办法是把程序的输入域划分为若干部分，然后从每个部分中选取少数代表性数据当作测试用例，每一类的代表性数据在测试中的作用等价于这一类中的其他值，也就是说，如果某一类中的一个例子发现了错误，这一等价类的其他例子也能发现同样的错误。反之，如果某一类中的一个例子没有发现错误，则这一类中的其他例子也不会查出错误。</p>
<h4 id="等价类划分方法"><a href="#等价类划分方法" class="headerlink" title="等价类划分方法"></a>等价类划分方法</h4><ul>
<li>如果输入条件规定了取值的范围或值的个数，则可以确定一个有效等价类和两个无效等价类</li>
<li>如果一个输入条件说明了一个“必须成立”的情况，则可划分一个有效等价类和一个无效等价类</li>
<li>如果输入条件规定了输入数据的一组可能的值，而且程序是用不同的方式处理每一种值，则可为每一种值划分一个有效等价类，并划分一个无效等价类</li>
<li>如果我们确知，已划分的某等价类中的各元素（例子）在程序中的处理方式是不同的，则应据此将此等价类进一步划分成更小的等价类</li>
<li>在确定了等价类之后，建立等价类表，列出所有划分出的等价类</li>
</ul>
<h4 id="基于等价类划分的用例设计"><a href="#基于等价类划分的用例设计" class="headerlink" title="基于等价类划分的用例设计"></a>基于等价类划分的用例设计</h4><ul>
<li>明确测试对象，非测试对象保证正确</li>
<li>为每个等价类规定一个唯一的编号</li>
<li>设计一个新的测试用例，使其尽可能多地覆盖尚未覆盖的有效等价类。重复这一步，最后使得所有有效等价类均被测试用例所覆盖</li>
<li>设计一个新的测试用例，使其只覆盖一个无效等价类。重复这一步使所有无效等价类被覆盖</li>
</ul>
<h3 id="等价类划分实战"><a href="#等价类划分实战" class="headerlink" title="等价类划分实战"></a>等价类划分实战</h3><ul>
<li>STEP1：根据测试需求可以分为三个等价类：<ul>
<li>一个有效数据的等价类，两个无效数据等价类</li>
<li>有效数据等价类就是：由那些对程序的规格说明有意义的、合理的输入数据所构成的集合</li>
<li>无效数据等价类就是：那些对程序的规格说明不合理的或无意义的输入数据所构成的集合</li>
</ul>
</li>
<li>STEP2：建立等价类表<ul>
<li>在实际工作中，我们通常在确立了等价类以后，把程序中所有等价类建立等价类表，以便在编写测试用例的时候有所依据</li>
</ul>
</li>
<li>STEP3：确定测试用例<ul>
<li>为等价类表中的每一个等价类分配一个唯一的编号</li>
<li>设计一个新的测试用例，使它能够尽量覆盖尚未覆盖的有效等价类</li>
<li>重复这一步骤，从而使所有有效等价类均被测试用例所覆盖</li>
<li>与上步类似，设计一个新的测试用例，使它只覆盖一个无效等价类</li>
<li>重复这一步骤，从而使所有无效等价类均被测试用例所覆盖</li>
</ul>
</li>
<li>STEP4：细化等价类划分</li>
<li>STEP5：完善测试用例</li>
</ul>
<h4 id="等价类的特点"><a href="#等价类的特点" class="headerlink" title="等价类的特点"></a>等价类的特点</h4><ul>
<li>测试相同的内容</li>
<li>如果等价类中的一个测试能够捕获一个缺陷，那么选择该等价类中的其他测试也能捕获该缺陷</li>
<li>如果等价类中的一个测试不能捕获缺陷，那么选择该等价类中的其他测试也不会捕获缺陷</li>
<li>如果正确地划分等价类，可以大大降低测试用例的数量，测试会准确有效</li>
<li>如果错误的将两个不同的等价类当作一个等价类，那么就会遗漏一种测试情况</li>
<li>相反的，把同一个等价类看作了两个不同的等价类，那么测试就会是冗余的</li>
</ul>
<h4 id="等价类划分要注意的问题"><a href="#等价类划分要注意的问题" class="headerlink" title="等价类划分要注意的问题"></a>等价类划分要注意的问题</h4><ul>
<li>不但要考虑有效等价类，也要考虑无效等价类</li>
<li>仔细划分，审查划分</li>
<li>过于粗略可能会漏掉软件缺陷</li>
<li>组织评审</li>
</ul>
<h3 id="边界值法"><a href="#边界值法" class="headerlink" title="边界值法"></a>边界值法</h3><h4 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h4><ul>
<li>边界值分析法是一种补充等价划分的测试用例设计技术，它不是选择等价类的任意元素，二是选择等价类边界的测试用例</li>
<li>实践证明，在设计测试用例时，对边界附近的处理必须给予足够的重视，为检验边界附近的处理专门设计测试用例，常常取得良好的测试效果</li>
<li>边界值分析法不仅重视输入条件边界，而且也从输出域导出测试用例</li>
</ul>
<h4 id="边界值设计的原则"><a href="#边界值设计的原则" class="headerlink" title="边界值设计的原则"></a>边界值设计的原则</h4><p>如果输入条件规定了取值范围，应以该范围的边界内及刚刚超过范围的边界外的值作为测试用例</p>
<p>如以a和b作为边界，测试用例应当包含a和b及略大于a和略小于b的值</p>
<h3 id="因果图-amp-判定表"><a href="#因果图-amp-判定表" class="headerlink" title="因果图&amp;判定表"></a>因果图&amp;判定表</h3><h4 id="因果图法"><a href="#因果图法" class="headerlink" title="因果图法"></a>因果图法</h4><p>等价类划分法和边界值分析方法都是着重考虑输入条件，而不考虑输入条件的各种组合、输入条件之间的相互制约关系，如果在测试时必须考虑输入条件的各种组合，则可能的组合数字将是天文数字，因此必须考虑采用一种适用于描述多种条件的组合、产生多个相应动作的测试方法，这就需要利用因果图（逻辑模型）</p>
<h4 id="因果图-判定表"><a href="#因果图-判定表" class="headerlink" title="因果图-判定表"></a>因果图-判定表</h4><p>因果图法基于这样的思想：一些程序的功能可以用决策表的形式来表示，并根据输入条件的组合情况规定相应的操作</p>
<p>因此，可以考虑为决策表中的每一列设计一个测试用例，以便测试程序在输入条件的某个组合下的输出是否正确</p>
<p>概括地说，因果图方法就是从程序规格说明书的描述中找出因（输入条件）和果（输出结果或程序状态的改变）</p>
<p>将因果图转化为判定表，为决策表中的每一列设计一个测试用例</p>
<p>这种方法考虑到了输入情况的各种组合以及各个输入情况之间的相互制约关系</p>
<h4 id="判定表"><a href="#判定表" class="headerlink" title="判定表"></a>判定表</h4><p>判定表（Decision Table）是分析和表达多逻辑条件下执行不同操作的工具</p>
<p>在程序设计发展的初期，判定表就已被当作编写程序的辅助工具了</p>
<p>因为它可以把复杂的逻辑关系和多种条件组合的情况表达得即具体又明确</p>
<p>判定表通常由四个部分组成：</p>
<ul>
<li>条件桩（Condition Stub）：列出了问题得所有条件，通常认为列出的条件的次序无关紧要</li>
<li>动作桩（Action Stub）：列出了问题规定可能采取的操作，这些操作的排列顺序没有约束</li>
<li>条件项（Condition Entry）：列出针对它左列条件的取值，在所有可能情况下的真假值</li>
<li>动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作</li>
</ul>
<h3 id="设计步骤（因果图-amp-判定表）"><a href="#设计步骤（因果图-amp-判定表）" class="headerlink" title="设计步骤（因果图&amp;判定表）"></a>设计步骤（因果图&amp;判定表）</h3><ol>
<li>分析软件规格说明中哪些是原因（即输入条件或输入条件的等价类），哪些是结果（即输出条件），并给每个原因和结果赋予一个标识符</li>
<li>分析软件规格说明中语义的内容，找出原因和结果之间、原因和原因之间对应的关系，根据这些关系画出因果图</li>
<li>由于语法或环境的限制，有些原因和原因之间、原因和结果之间的组合情况不可能出现。为表明这些特定的情况，在因果图上使用一些记号表明约束或限制条件</li>
<li>把因果图转换为判定表</li>
<li>根据判定表中的每一列设计测试用例</li>
</ol>
<h3 id="正交实验法"><a href="#正交实验法" class="headerlink" title="正交实验法"></a>正交实验法</h3><p>正交试验设计法（Orthogonal experimental design），是从大量的试验点中挑选出适量的、有代表性的点，，应用依据伽罗卡瓦理论导出的“正交表”，合理地安排实验的一种科学的试验设计方法</p>
<ul>
<li>指标：通常把判断试验结果优劣的标准叫做试验的指标</li>
<li>因子（因素Factor）：所有影响试验指标的条件</li>
<li>因子的状态（水平Level）：而影响实验因子的，叫做因子的状态（因子变量的取值）</li>
</ul>
<h4 id="正交实验法设计步骤"><a href="#正交实验法设计步骤" class="headerlink" title="正交实验法设计步骤"></a>正交实验法设计步骤</h4><ol>
<li>提取功能说明，构造因子–状态表<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">因子1</th>
<th align="center">因子2</th>
<th align="center">…</th>
<th align="center">因子n</th>
</tr>
</thead>
<tbody><tr>
<td align="center">状态1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">状态2</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">…</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">状态m</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li>加权筛选，生成因素分析表<br>计算各因子和状态的权值，删去一部分权值较小，即重要性较小的因子或状态，使最后生成的测试用例集缩减到允许范围</li>
<li>利用正交表构造测试数据集<ul>
<li>如果各个因子的状态树是不统一的，几乎不可能出现均匀的情况，必须首先用逻辑命令来组合各因子的状态，作出布尔图</li>
<li>根据布尔图得到相应结束的正交表</li>
<li>依照因果图上根节点到叶子节点的顺序逐步替换正交表上的中间节点，得到最终的正交表</li>
</ul>
</li>
<li>利用正交表每行数据构造测试用例<ul>
<li>正交表<br>正交表的表现形式：Ln(t^c)<br>其中：L为正交表的代号，n为行数（试验次数），t为水平数，c为列数（因素数）</li>
<li>例如：L4(2^3)<br>它表示需做4次实验，最多可观察3个因素，每个因素均为2水平</li>
</ul>
</li>
<li>一个正交表也可以各列的水平数不相等，我们称它为混合型正交表，如L8(2^4 4^1)<br>此表的5列中，有1列为4水平，4列为2水平</li>
</ol>
<h4 id="如何查找正交表"><a href="#如何查找正交表" class="headerlink" title="如何查找正交表"></a>如何查找正交表</h4><ol>
<li><a href="http://support.sas.com/techsup/technote/ts723_Designs.txt">Technical Support(support.sas.com)</a></li>
<li><a href="https://www.york.ac.uk/depts/maths/tables/orthogonal.htm">Dr.GenichiTaguchi设计的正交表</a></li>
</ol>
<h3 id="测试场景设计"><a href="#测试场景设计" class="headerlink" title="测试场景设计"></a>测试场景设计</h3><ul>
<li>现在的软件几乎都是用事件触发来控制流程的。事件触发时的情景形成了场景，而同一事件不同的触发顺序和处理结果就形成了事件流</li>
<li>这种在软件设计方面的思想可以引入到软件测试中，可以生动地描绘出事件触发时的情景，有利于设计测试用例，同时使测试用例更容易理解和执行</li>
</ul>
<h4 id="场景法基础设计"><a href="#场景法基础设计" class="headerlink" title="场景法基础设计"></a>场景法基础设计</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/157e96bd89a8454995bcfeb663d8f35a.png" alt="场景法基础设计"></p>
<ul>
<li><p>经过用例的每条路径都用基本流和备选流来表示，直黑线表示基本流，是经过用例的最简单的路径</p>
</li>
<li><p>备选流用不同的色彩表示，一个备选流可能从基本流开始，在某个特定条件下执行，然后重新加入基本流中（如备选流1和3）</p>
</li>
<li><p>也可能起源于另一个备选流（如备选流2），或者终止用例而不再重新加入某个流（如备选流2和4）</p>
</li>
<li><p>每个经过用例的可能路径，可以确定不同的用例场景</p>
</li>
<li><p>从基本流开始，再将基本流和备选流结合起来，可以确定以下用例场景：</p>
<ul>
<li>场景1 基本流</li>
<li>场景2 基本流 备选流1</li>
<li>场景3 基本流 备选流1 备选流2</li>
<li>场景4 基本流 备选流3</li>
<li>场景5 基本流 备选流3 备选流1</li>
<li>场景6 基本流 备选流3 备选流1 备选流2</li>
<li>场景7 基本流 备选流4</li>
<li>场景8 基本流 备选流3 备选流4</li>
</ul>
</li>
<li><p>根据说明，描述出程序的基本流和各项备选流</p>
</li>
<li><p>根据基本流和各项备选流生成不同的场景</p>
</li>
<li><p>对每一个场景生成相应的测试用例</p>
</li>
<li><p>对生成的所有测试用例重新复审，去掉多余的测试用例，测试用例确定后，对每一个测试用例确定测试数据值</p>
</li>
</ul>
<h3 id="用例设计的综合运用"><a href="#用例设计的综合运用" class="headerlink" title="用例设计的综合运用"></a>用例设计的综合运用</h3><ol>
<li>测试用例项划分<br>测试用例划分的经典方法是瀑布模型（不是软件开发模型的瀑布模型），从上到下，逐渐细分，大模块包括小模块，小模块包括更小的模块<br>要从更多的角度切入系统，把系统切分成一块一块的，来进行测试，从而保证测试大项的完整性</li>
<li>切面设计<ul>
<li>功能点切面：最常见的切面，通常认为页面上的一个按钮就是一个功能点。根据功能的复杂程度，按每个功能进行用例的撰写</li>
<li>隐含切面：完整业务流程的测试；从需求、业务角度进行编写</li>
</ul>
</li>
<li>功能点用例设计<ul>
<li>任何情况下都必须使用边界值分析方法，经验表明用这种方法设计出测试用例发现程序错误的能力最强</li>
<li>必要时用等价类划分方法补充一些测试用例</li>
<li>如果程序的功能说明中含有输入条件的组合情况，则一开始就可选用因果图法</li>
<li>如果程序业务复杂度比较高，则适当使用场景法补充一部分测试用例</li>
</ul>
</li>
</ol>
<h2 id="测试执行管理"><a href="#测试执行管理" class="headerlink" title="测试执行管理"></a>测试执行管理</h2><h3 id="测试执行过程"><a href="#测试执行过程" class="headerlink" title="测试执行过程"></a>测试执行过程</h3><pre class="mermaid">flowchart LR
A[项目提测] --> B[冒烟测试]
B --> |通过| C[系统测试] --> D[用例执行]
B --> |未通过| A
D --> |通过| E[测试通过]
D --> |失败| F[提出缺陷] --> G[研发修改] --> D</pre>

<h3 id="测试执行阶段的主要任务"><a href="#测试执行阶段的主要任务" class="headerlink" title="测试执行阶段的主要任务"></a>测试执行阶段的主要任务</h3><ul>
<li>确定测试用例的优先级</li>
<li>开发测试规程并确定优先级，创建测试数据，同时也可以准备测试用具和设计自动化测试脚本</li>
<li>根据测试规程创建测试套件，以提高测试执行的效率</li>
<li>确认已经正确搭建了测试环境</li>
<li>根据计划的执行顺序，通过手工或使用测试工具来执行测试规程</li>
<li>记录测试执行的结果，以及被测软件、测试工具和测试件的标识和版本</li>
<li>将实际结果和预期结果进行比较</li>
<li>对实际结果和预期结果之间的差异，作为事件上报，并且进行分析以确定引起差异的原因</li>
<li>缺陷修正后，重新进行测试活动</li>
</ul>
<h3 id="测试准入准出"><a href="#测试准入准出" class="headerlink" title="测试准入准出"></a>测试准入准出</h3><h4 id="测试准入标准"><a href="#测试准入标准" class="headerlink" title="测试准入标准"></a>测试准入标准</h4><ul>
<li>开发编码结束，并在开发环境已完成单元测试</li>
<li>需求上规定的功能均已实现；如没有完全实现，请提供测试范围</li>
<li>已完成集成测试，被测系统的基本流程可以走通，界面上的功能均实现，经过代码评审并符合软件编码规范</li>
<li>开发提交最新版本代码，以此为基线，提交并通知测试组进行测试</li>
<li>兼容性测试要求明确</li>
<li>安全测试和性能测试范围和要求</li>
</ul>
<h4 id="测试暂停、停止"><a href="#测试暂停、停止" class="headerlink" title="测试暂停、停止"></a>测试暂停、停止</h4><ul>
<li>测试人员先进行冒烟测试，若发现重大缺陷或bug过多时、或者流程卡壳导致基本流程无法走通，测试无法正常进行，可以暂停测试并返回开发</li>
<li>被测项目需调整而暂停的，测试也相应暂停</li>
<li>存在其他优先级更高的任务时，可以向领导申请暂停测试</li>
<li>被测系统经过系统测试，达到系统准出标准，可以停止测试</li>
</ul>
<h4 id="测试准出标准"><a href="#测试准出标准" class="headerlink" title="测试准出标准"></a>测试准出标准</h4><table>
<thead>
<tr>
<th align="center">序号</th>
<th>准出标准</th>
<th align="center">是</th>
<th align="center">否</th>
<th align="center">日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>被测项目满足需求原型的要求？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td>所有测试用例都已经通过评审？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td>所有测试用例都已成功执行？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td>测试覆盖率是否达到100%？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td>所有发现的缺陷都记录在缺陷管理系统？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6</td>
<td>一二级错误修复率达到100%？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">7</td>
<td>三四级错误修复率达到95%？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8</td>
<td>所有遗留问题都已有解决方案？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td>性能指标是否达到要求？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">10</td>
<td>兼容性测试（IE8，Chrome，火狐）是否满足？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">11</td>
<td>安全性测试是否达到要求？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">12</td>
<td>产出系统测试总结报告？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="缺陷管理"><a href="#缺陷管理" class="headerlink" title="缺陷管理"></a>缺陷管理</h3><h4 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h4><ul>
<li>缺陷是一种泛称，它可以指功能的错误，也可以指性能低下，易用性差等</li>
<li>并不是所有测试人员都能提交被开发认可的缺陷，也不是测试员在任何时候都能提交被开发认可的缺陷</li>
</ul>
<h4 id="什么是软件缺陷"><a href="#什么是软件缺陷" class="headerlink" title="什么是软件缺陷"></a>什么是软件缺陷</h4><ol>
<li>软件未达到产品说明标明的功能</li>
<li>软件出现了产品说明书指明不会出现的错误</li>
<li>软件功能超出产品说明出指明范围</li>
<li>软件未达到产品说明书虽未指出但应达到的目标</li>
<li>软件测试员认为软件难以理解、不易使用、运行速度缓慢，或者最终用户认为不好</li>
</ol>
<h4 id="缺陷产生的原因"><a href="#缺陷产生的原因" class="headerlink" title="缺陷产生的原因"></a>缺陷产生的原因</h4><ul>
<li>工期短，任务大</li>
<li>程序设计错误</li>
<li>文档不完善</li>
<li>沟通交流不够</li>
<li>软硬件支持不完善</li>
<li>软件的复杂性</li>
<li>需求不断变化</li>
</ul>
<h4 id="发现缺陷"><a href="#发现缺陷" class="headerlink" title="发现缺陷"></a>发现缺陷</h4><ol>
<li>用户体验不够好</li>
<li>界面上有明显的错误信息</li>
<li>功能不完备，没有按照需求说明编写代码，致使某些功能缺失</li>
<li>功能不完善，不能正常运行或者运行的过程中出现程序崩溃、停止运行的情况</li>
<li>逻辑不正确，与需求说明书、测试用例不符</li>
<li>模块之间的交互性不好，与其他的模块做集成测试时遇到问题</li>
<li>程序的性能不够好，不能承载压力考验</li>
</ol>
<h3 id="缺陷报告–注意事项"><a href="#缺陷报告–注意事项" class="headerlink" title="缺陷报告–注意事项"></a>缺陷报告–注意事项</h3><h4 id="BUG重现"><a href="#BUG重现" class="headerlink" title="BUG重现"></a>BUG重现</h4><ol>
<li>不要想当然地接受任何假设，要做好记录</li>
<li>查找时间依赖和竞争条件的问题</li>
<li>边界条件软件缺陷、内存缺陷和数据溢出等白盒问题可能会慢慢自己显露出来</li>
<li>状态缺陷仅在特定软件状态中显露出来</li>
<li>考虑资源依赖性和内存、网络、硬件共享的相互作用</li>
</ol>
<h4 id="无法重现的BUG"><a href="#无法重现的BUG" class="headerlink" title="无法重现的BUG"></a>无法重现的BUG</h4><ul>
<li>首先，应当对这样的缺陷进行详细的记录，并尽快提交给开发人员</li>
<li>其次，对于寻找难以再现的缺陷要合理地安排时间，要考虑到测试项目的整体进度，对一时难以再现的缺陷可以暂时搁置，以保证项目的正常进度</li>
<li>最后在测试过程中对未再现缺陷予以关注</li>
</ul>
<h4 id="缺陷报告"><a href="#缺陷报告" class="headerlink" title="缺陷报告"></a>缺陷报告</h4><ul>
<li>缺陷报告是对缺陷进行记录、分类和跟踪的文档</li>
<li>软件测试人员的任务之一就是书写良好的软件缺陷报告</li>
<li>提供准确、完整、简洁、一致的缺陷报告是体现软件测试的专业性、高质量的主要评价指标</li>
<li>通常，缺陷报告的直接读者是软件开发人员和质量管理人员，除此之外，来自市场和技术支持等部门的人也可能需要查看缺陷情况</li>
</ul>
<h4 id="缺陷报告包含信息"><a href="#缺陷报告包含信息" class="headerlink" title="缺陷报告包含信息"></a>缺陷报告包含信息</h4><ul>
<li>易于搜索软件测试报告的缺陷</li>
<li>报告的软件缺陷进行了必要的隔离，报告的缺陷信息具体、准确</li>
<li>软件开发人员希望获得缺陷的本质特征和复现步骤</li>
<li>市场和技术支持等部门希望获得缺陷类型分布以及对市场和用户的影响程度</li>
</ul>
<h4 id="缺陷报告的写作准则（5C）"><a href="#缺陷报告的写作准则（5C）" class="headerlink" title="缺陷报告的写作准则（5C）"></a>缺陷报告的写作准则（5C）</h4><ul>
<li>Correct（准确）：每个组成部分的描述准确，不会引起误解</li>
<li>Clear（清晰）：每个组成部分的描述清晰，易于理解</li>
<li>Concise（简洁）：只包含必不可少的信息，不包括任何多余的内容</li>
<li>Complete（完整）：包含复现该缺陷的完整步骤和其他本质信息</li>
<li>Consistent（一致）：按照一致的格式书写全部缺陷报告</li>
</ul>
<h4 id="缺陷报告的组织架构"><a href="#缺陷报告的组织架构" class="headerlink" title="缺陷报告的组织架构"></a>缺陷报告的组织架构</h4><ol>
<li>缺陷的标题</li>
<li>缺陷的基本信息</li>
<li>测试的软件和硬件环境</li>
<li>测试的软件版本</li>
<li>缺陷的类型</li>
<li>缺陷的严重程度</li>
<li>缺陷的处理优先级</li>
<li>复现缺陷的操作步骤</li>
<li>缺陷的实际结果描述</li>
<li>期望的正确结果描述</li>
<li>注释文字和截取的缺陷图像</li>
</ol>
<h4 id="缺陷标题"><a href="#缺陷标题" class="headerlink" title="缺陷标题"></a>缺陷标题</h4><ul>
<li>尽量按缺陷发生的原因与结果的方式书写（“执行完A后，发生B” 或者 “发生B，当A执行后”）</li>
<li>避免使用模糊不清的词语，例如“功能中断”，“功能不正确”，“行为不起作用”等。应该使用具体文字说明功能如何中断，如何不正确，或如何不起作用</li>
<li>为了方便搜索和查询，请使用关键字</li>
<li>为了便于他人理解，避免使用术语、俚语或过分具体的测试细节</li>
</ul>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><table>
<thead>
<tr>
<th>原始描述</th>
<th>错误原因</th>
<th>改进的标题</th>
</tr>
</thead>
<tbody><tr>
<td>英文单词的连字符不管用</td>
<td>描述太笼统。什么时候不起作用？</td>
<td>在行末尾换行时，不能根据英文单词长度设置连字符。</td>
</tr>
<tr>
<td>段落调整出现错误状态</td>
<td>描述太笼统。不正确的行为是什么？</td>
<td>选定两个单词，启动单词“字间距”自动调整后间隔排版错误</td>
</tr>
<tr>
<td>警告：该命令产生了错误的结果。</td>
<td>没有包含原因与结果信息。描述内容太长。</td>
<td>更新头像图像保存到服务器时，警告：“错误”。</td>
</tr>
<tr>
<td>在鼠标点击执行每一个拷贝或复制的功能之后，响应事件很长。</td>
<td>没有指明原因和结果，包括了过分详细的细节信息</td>
<td>拷贝和复制功能执行效率低</td>
</tr>
<tr>
<td>插入的引号成为特殊符号</td>
<td>信号没有充分隔离。所有的引号都如此吗？什么类型的引号。</td>
<td>在文档中插入一个智能引号成为不可识别的字符串。</td>
</tr>
</tbody></table>
<h4 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h4><ul>
<li>复现步骤包括如何使别人能够很容易地复现该缺陷的完整步骤。为了达到这个要求，复现步骤的信息必须是完整的、准确的、简明的、可复现的</li>
<li>但是实际如阿健测试过程中，总是存在一些不良的缺陷报告，主要的问题在于多余步骤、可读性差、难以理解、缺失步骤等</li>
<li>提供测试的预备步骤和信息</li>
<li>简单地一步一步地引导复现该缺陷</li>
<li>每一个步骤尽量只记录一个操作</li>
<li>每一个步骤前使用数字对步骤编号</li>
<li>尽量使用短语和短句，避免复杂句型和句式</li>
<li>复现的步骤要完整，准确，简短</li>
<li>没有缺漏任何操作步骤</li>
<li>每个步骤都是准确无误的</li>
<li>没有任何多余的步骤</li>
<li>将常见步骤合并为较少步骤</li>
<li>只记录每个操作步骤是什么，不需要包括每个步骤的执行结果</li>
</ul>
<h4 id="缺陷报告注意事项"><a href="#缺陷报告注意事项" class="headerlink" title="缺陷报告注意事项"></a>缺陷报告注意事项</h4><ul>
<li>缺陷报告已经向读者包含完整、准确、必要的信息了吗？</li>
<li>一个缺陷报告中是否只报告了一种缺陷？</li>
<li>读者是否能容易的搜索该缺陷？</li>
<li>步骤是否可以完全复现而且表达清楚吗？</li>
<li>是否包含了复现该缺陷需要的环境变量或测试所用的数据文件？</li>
<li>缺陷的标题是按照原因与结果的方式书写的吗？</li>
<li>实际结果和期望结果是否描述不够清楚而容易引起歧义吗？</li>
</ul>
<h3 id="缺陷报告的原则"><a href="#缺陷报告的原则" class="headerlink" title="缺陷报告的原则"></a>缺陷报告的原则</h3><ul>
<li>组织Structure: 测试人员应该采用深思熟虑的，小心谨慎的方法执行测试，并且做详尽的记录。这样可以促使他们对待测试有很好的认识。当错误发生的时候，一个有组织的测试人员能够指导最早出现问题的地方。</li>
<li>重现Reproduce: 测试人员在编写缺陷报告之前必须在检查问题是否可重现。如果错误不可再重现，仍然应该写下来，但是必须说明问题的偶然性。一个好的处理原则就是在编写缺陷报告之前必须反复尝试3次。</li>
<li>隔离Isolate: 在尝试编写缺陷报告之前，必须试着隔离错误。可以采用改变一些变量的方法，如系统的配置，它可能可以改变错误的症状。这些信息可以为开发人员着手调试提供思路。</li>
<li>归纳Generalize: 发现了一个已隔离的，可重现的问题后，应该对问题进行归纳。同一个问题是否出现在其他的模块或其他的地方？同一个故障是否有更加严重的问题？</li>
<li>对比Compare: 如果测试人员以前曾经验证过现在出错的测试用例，那么他就应该检查以前的测试结果以检查相同的条件以前的测试是否通过。如果是的话，那么这个问题就像是一个回归的错误。注意由于同一测试条件有可能出现在多个测试用例中，这个步骤就不仅仅只是检查一个测试用例在以前的多个结果。</li>
<li>总结Summarize: 在缺陷报告的第一行协商错误的总结是非常关键的。测试人员要花些时间思考已发现的错误对客户有何影响。这不仅仅要求测试人员编写的报告要能够吸引读者，使和管理层的沟通清晰，还要能够帮助设置错误修复的优先级别。</li>
<li>精简Condense: 在缺陷报告的初稿完成后，测试人员应该反复阅读它，集中剔除那些没有关系的步骤或词语。隐含的或模糊的说明和那些由于对没有任何关系的细节或者那些在重现错误过程中不需要的步骤而消磨报告欢迎程度的无穷唠叨都不是缺陷报告的目标。</li>
<li>消除歧义Disambiguate: 测试人员在精简空话的同时或其之后随即应该再仔细检查报告是否会有产生误解的地方。测试人员应该尽量避免使用模糊的，会产生歧义的主观的词语。目标是使用能够表述事实，清楚的，不会产生争执的词语。</li>
<li>中立Neutralize: 作为坏消息的传递人，和善地提交信息是一个挑战。如同所有地错误总结一样，独立的缺陷报告在措辞方面应该保持公正。攻击开发人员，指责潜在的错误，企图诙谐或使用挖苦将引起开发人员的憎恶，并且使注意力从“提高产品质量“这个大的目标上转移开了。</li>
<li>检查Review: 一旦测试人员感觉缺陷报告是他能够编写地最好版本，他应该将报告再给一个或多个同行进行检查。在允许的时间内，测试小组应该尽可能提交最好的缺陷报告。</li>
</ul>
<h3 id="缺陷跟踪"><a href="#缺陷跟踪" class="headerlink" title="缺陷跟踪"></a>缺陷跟踪</h3><pre class="mermaid">graph LR
  A[提交缺陷] --> B[指派缺陷] --> C{确认缺陷}
  C --> |是|D{推迟处理}
  C --> |否|E{回归缺陷}
  D --> |否|F[处理缺陷] --> E
  D --> |是|G[遗留缺陷] --> |后续版本处理|F
  E --> |通过|H[关闭缺陷]
  E --> |未通过|I[重新打开] --> C</pre>

<table>
  <tbody>
    <tr>
      <th>步骤</th>
      <th>人员</th>
      <th>任务</th>
      <th>缺陷状态</th>
    </tr>
    <tr>
      <td align="center">1</td>
      <td>测试人员</td>
      <td>提交缺陷</td>
      <td>New</td>
    </tr>
    <tr>
      <td align="center">2</td>
      <td>测试负责人</td>
      <td>分配缺陷</td>
      <td></td>
    </tr>
    <tr>
      <td align="center">3</td>
      <td>项目或开发负责人</td>
      <td>分配缺陷</td>
      <td></td>
    </tr>
    <tr>
      <td align="center" rowspan="4">4</td>
      <td rowspan="2">开发人员</td>
      <td>验证缺陷--是缺陷</td>
      <td>Open</td>
    </tr>
    <tr>
      <td>验证缺陷--不是缺陷</td>
      <td>Declined</td>
    </tr>
    <tr>
      <td rowspan="2">开发人员</td>
      <td>对Open的缺陷再次确认，若可复现，则修正并记录缺陷产生原因和修正方法</td>
      <td>Fixed</td>
    </tr>
    <tr>      
      <td>对Open的缺陷再次确认，若不可重现</td>
      <td>Need More Info</td>
    </tr>
    <tr>
      <td align="center">5</td>
      <td>测试人员</td>
      <td>对Declined的缺陷进行验证-不是缺陷</td>
      <td>Closed</td>
    </tr>
    <tr>
      <td align="center">6</td>
      <td>评审委员会（由开发经理-测试经理-项目经理-市场人员等组成）</td>
      <td>对延期解决和分歧缺陷进行评审、分析、讨论和仲裁</td>
      <td></td>
    </tr>
    <tr>
      <td align="center" rowspan="2">7</td>
      <td rowspan="2">测试人员</td>
      <td>对Fixed的缺陷在新软件版本Build验证缺陷是否修复，若已经修复</td>
      <td>Closed</td>
    </tr>
    <tr>
      <td>对Fixed的缺陷在新软件版本Build验证缺陷是否修复，若没有修复</td>
      <td>Open</td>
    </tr>
  </tbody>
</table>

<h4 id="缺陷跟踪管理系统"><a href="#缺陷跟踪管理系统" class="headerlink" title="缺陷跟踪管理系统"></a>缺陷跟踪管理系统</h4><p>早期的缺陷跟踪大都是以缺陷记录单的形式完成，现在还有很多项目还用此方法，但是随着用户对软件功能需求的不断增加，软件算法和复杂度都发生了很多变化，随之而来的是软件缺陷的增长，这给缺陷跟踪带来了很大挑战。于是，缺陷跟踪管理系统应运而生<br>在软件行业发展历程中，曾经或者正在被大量使用的缺陷管理系统包括JIRA, BUGZILLA, QC, 禅道等，而目前，除了部分大型IT公司拥有自研的缺陷跟踪管理系统外，很多公司应用禅道来进行缺陷跟踪甚至是项目管理</p>
<h3 id="禅道项目管理系统"><a href="#禅道项目管理系统" class="headerlink" title="禅道项目管理系统"></a>禅道项目管理系统</h3><p><a href="https://www.zentao.net/">禅道</a>是一款基于Scrum思想并集产品管理、项目管理、测试管理于一体，同时还包含了事务管理、组织管理等诸多功能的项目管理软件</p>
<h4 id="用户角色"><a href="#用户角色" class="headerlink" title="用户角色"></a>用户角色</h4><ul>
<li>系统管理员(Admin): 系统管理员主要负责添加用户，分配权限</li>
<li>产品经理(Product Owner): 产品人员主要负责产品管理</li>
<li>项目经理(Project Manager): 通过项目，协调产品人员，开发人员，测试人员完成产品</li>
<li>开发人员(Developer): 开发人员负责产品的研发</li>
<li>测试人员(QA): 测试人员保证产品的质量</li>
</ul>
<h4 id="最简使用"><a href="#最简使用" class="headerlink" title="最简使用"></a>最简使用</h4><ul>
<li>只使用禅道来进行产品管理</li>
<li>使用禅道来进行项目任务管理</li>
<li>只使用禅道来做BUG管理</li>
<li>个人使用禅道来做事物跟踪管理</li>
</ul>
<h4 id="项目模式基本流程"><a href="#项目模式基本流程" class="headerlink" title="项目模式基本流程"></a>项目模式基本流程</h4><ol>
<li>产品经理创建产品</li>
<li>产品经理创建需求</li>
<li>项目经理创建项目</li>
<li>项目经理确定项目要做的需求</li>
<li>项目经理分解任务，指派到人</li>
<li>测试人员测试，提交bug</li>
</ol>
<h3 id="易用性测试"><a href="#易用性测试" class="headerlink" title="易用性测试"></a>易用性测试</h3><ul>
<li>易用性测试是指用户使用软件时是否感觉方便，比如是否最多点击鼠标三次就可以达到用户的目的</li>
<li>易用性和可用性存在一定的区别，可用性是指是否可以使用，而易用性是指是否方便使用</li>
</ul>
<h4 id="易用性测试内容"><a href="#易用性测试内容" class="headerlink" title="易用性测试内容"></a>易用性测试内容</h4><ul>
<li>易用性测试包括针对应用程序的测试，同时还包括对用户手册系统文档的测试。通常采用质量外部模型来评价易用性</li>
<li>包括如下方面的测试：<ol>
<li>易理解性</li>
<li>易学习性</li>
<li>易操作性</li>
<li>吸引性</li>
<li>依从性</li>
</ol>
</li>
<li>易用性测试方法<ul>
<li>导航测试<ul>
<li>通过考虑下列问题，可以决定一个应用系统是否易于导航：<ul>
<li>导航是否直观？</li>
<li>系统的主要部分是否可通过主页存取？</li>
<li>系统是否需要站点地图、搜索引擎或其他的导航帮助？</li>
</ul>
</li>
</ul>
</li>
<li>图形测试<ul>
<li>在应用系统中，适当的图片和动画既能起到广告宣传的作用，又能起到美化页面的功能</li>
<li>一个应用系统的图形可以包括图片、动画、边框、颜色、字体、背景、按钮等</li>
<li>要确定图形有明确的用途，图片或动画不要胡乱地堆在一起，以免浪费传输时间</li>
<li>应用系统的图片尺寸要尽量地小，并且要能清楚地说明某件事情，一般都链接到某个具体的页面</li>
<li>验证所有页面字体的风格是否一致</li>
<li>背景颜色应该与字体颜色和前景颜色相搭配</li>
<li>图片的大小和质量也是一个很重要的因素，一般采用JPG或GIF压缩</li>
</ul>
</li>
<li>内容测试<ul>
<li>内容测试用来检验应用系统提供信息的正确性、准确性和相关性</li>
</ul>
</li>
<li>整体界面测试<ul>
<li>整体界面是指整个应用系统的页面结构设计，是给用户的一个整体感</li>
<li>例如<ul>
<li>当用户浏览应用系统时是否感到舒适，是否凭直觉就知道要找的信息在什么地方？</li>
<li>整个应用系统的设计风格是否一致？</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="测试点总结"><a href="#测试点总结" class="headerlink" title="测试点总结"></a>测试点总结</h4><h5 id="控件类"><a href="#控件类" class="headerlink" title="控件类"></a>控件类</h5><table>
<thead>
<tr>
<th align="center">编号</th>
<th>测试内容</th>
<th>是否通过</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>按钮名称易懂，用词准确，与同一界面上的其他按钮易于区分</td>
<td></td>
</tr>
<tr>
<td align="center">2</td>
<td>常见按钮支持快捷方式</td>
<td></td>
</tr>
<tr>
<td align="center">3</td>
<td>相同或相近功能的按钮用Frame框起来，并有功能说明或标题</td>
<td></td>
</tr>
<tr>
<td align="center">4</td>
<td>完成同一功能或任务的元素集中放置</td>
<td></td>
</tr>
<tr>
<td align="center">5</td>
<td>应首先输入数据和重要信息的空间在Tab顺序中靠前，并放在窗口上较醒目的位置</td>
<td></td>
</tr>
<tr>
<td align="center">6</td>
<td>选项卡控件(Tab)支持在页面间的快捷切换，常用快捷键Ctrl+Tab</td>
<td></td>
</tr>
<tr>
<td align="center">7</td>
<td>默认按钮要支持“回车”即选操作</td>
<td></td>
</tr>
<tr>
<td align="center">8</td>
<td>选择常用功能或数值作为默认值</td>
<td></td>
</tr>
<tr>
<td align="center">9</td>
<td>复选框、单选框、列表框、下拉列表框的内容或条目多的时候按选择概率的高低或字母顺序排序</td>
<td></td>
</tr>
<tr>
<td align="center">10</td>
<td>复选框或单选框有默认选项</td>
<td></td>
</tr>
<tr>
<td align="center">11</td>
<td>界面控件较小时使用下拉列表框而不用单选框</td>
<td></td>
</tr>
<tr>
<td align="center">12</td>
<td>选项条目较少时使用单选框，相反使用下拉列表框</td>
<td></td>
</tr>
<tr>
<td align="center">13</td>
<td>专业性强的软件要使用相关的专业术语，通用性界面则提倡使用通用性术语</td>
<td></td>
</tr>
<tr>
<td align="center">14</td>
<td>不同界面的通用按钮位置保持一致</td>
<td></td>
</tr>
<tr>
<td align="center">15</td>
<td>常用按钮的等价按钮保持一致</td>
<td></td>
</tr>
<tr>
<td align="center">16</td>
<td>对可能给用户带来损失的操作最好支持可逆性处理</td>
<td></td>
</tr>
<tr>
<td align="center">17</td>
<td>对可能造成等待时间较长的操作应该提供取消功能，并显示操作的状态</td>
<td></td>
</tr>
<tr>
<td align="center">18</td>
<td>根据需要，程序自动过滤输入的空格</td>
<td></td>
</tr>
</tbody></table>
<h5 id="菜单测试"><a href="#菜单测试" class="headerlink" title="菜单测试"></a>菜单测试</h5><table>
<thead>
<tr>
<th align="center">编号</th>
<th>测试内容</th>
<th>是否通过</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>常用菜单项要有快捷键</td>
<td></td>
</tr>
<tr>
<td align="center">2</td>
<td>菜单项前的图标能直观地代表要完成的操作</td>
<td></td>
</tr>
<tr>
<td align="center">3</td>
<td>一组菜单的使用有先后要求或有向导作用时，按先后次序排列</td>
<td></td>
</tr>
<tr>
<td align="center">4</td>
<td>没有顺序要求的菜单按使用频率和重要性排列，常用的和重要的放前面</td>
<td></td>
</tr>
<tr>
<td align="center">5</td>
<td>主菜单的宽度要接近，字数不多于四个，每个菜单项的字数最好能相同</td>
<td></td>
</tr>
<tr>
<td align="center">6</td>
<td>工具栏的图标可以根据用户的需求进行定制</td>
<td></td>
</tr>
<tr>
<td align="center">7</td>
<td>相同或相近功能的工具栏放在一起</td>
<td></td>
</tr>
<tr>
<td align="center">8</td>
<td>工具栏的图标能直观地代表要完成的操作</td>
<td></td>
</tr>
<tr>
<td align="center">9</td>
<td>状态条能显示用户切实需要的信息。如果某一操作需要的时间较长，还应该显示进度条和进程提示</td>
<td></td>
</tr>
<tr>
<td align="center">10</td>
<td>滚动条的长度根据显示信息的长度或宽度及时变换</td>
<td></td>
</tr>
<tr>
<td align="center">11</td>
<td>菜单和工具栏有清楚的界限</td>
<td></td>
</tr>
<tr>
<td align="center">12</td>
<td>菜单和状态条通常使用5号字体</td>
<td></td>
</tr>
</tbody></table>
<h5 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h5><table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">快捷键类型</th>
<th>测试内容</th>
<th align="center">是否通过</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">编辑</td>
<td>Ctrl+A 全选；Ctrl+C 复制；Ctrl+V 粘贴；Ctrl+X 剪切；Ctrl+Z 撤销操作；Ctrl+Y 恢复操作；Ctrl+D 删除；Ctrl+F 寻找；Ctrl+H 替换；Ctrl+I 插入；Ctrl+Tab 下一个Tab窗口</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">文件操作</td>
<td>Ctrl+P 打印；Ctrl+W 关闭；Ctrl+N 新建；Ctrl+S 保存；Ctrl+O 打开</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">主菜单</td>
<td>Alt+F 文件；Alt+E编辑；Alt+W 窗口；Alt+H 帮助</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">Windows保留键</td>
<td>Ctrl+Esc 任务列表；Crtl+F4 关闭窗口；Alt+F4 结束应用；Alt+Tab 切换到下一应用；Enter 缺省按钮&#x2F;确认操作；Esc 取消按钮&#x2F;取消操作；Shift+F1 上下文相关帮助</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">其他组合</td>
<td>Alt+N 否；Alt+D 删除；Alt+Q 退出；Alt+A 添加；Alt+E 编辑；Alt+B 浏览；Alt+R 读；Alt+W 写</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h3><p>兼容测试简称CTS，指对所设计程序与硬件、软件之间的兼容性的测试<br>一般来说，兼容性指能同时容纳多个方面，在计算机术语上兼容是指几个硬件之间、几个软件之间或是软硬件之间的相互配合程度<br>对于我们测试来说，通俗一点的理解可以认为是被测软件在不同的硬件平台（PC&#x2F;Mobile），不同的软件（浏览器），不同的操作系统平台、不同的网络环境中是否能够很友好运行的测试</p>
<h4 id="兼容性测试–分类"><a href="#兼容性测试–分类" class="headerlink" title="兼容性测试–分类"></a>兼容性测试–分类</h4><ul>
<li>兼容性测试<ul>
<li>Web兼容测试<ul>
<li>浏览器兼容</li>
<li>屏幕尺寸、分辨率</li>
<li>操作系统</li>
</ul>
</li>
<li>APP兼容测试<ul>
<li>设备型号兼容测试</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="兼容性测试–作用"><a href="#兼容性测试–作用" class="headerlink" title="兼容性测试–作用"></a>兼容性测试–作用</h4><p>兼容性测试是软件测试过程必不可少的一个过程，没有兼容测试的测试是不完整的测试，兼容性测试的存在是有一定作用的</p>
<ol>
<li>兼容性测试能够进一步提高产品的质量，提高用户体验</li>
<li>兼容性测试能使软件与尽可能多的其他软件“和平共处”，尽可能达到平台无关性</li>
<li>兼容性测试能尽可能地保证软件存在地价值，它是衡量一个软件质量的重要指标</li>
<li>兼容性测试能够使软件产品的市场更广阔</li>
</ol>
<h4 id="Web兼容性测试"><a href="#Web兼容性测试" class="headerlink" title="Web兼容性测试"></a>Web兼容性测试</h4><h5 id="Web兼容性测试方向"><a href="#Web兼容性测试方向" class="headerlink" title="Web兼容性测试方向"></a>Web兼容性测试方向</h5><ul>
<li>浏览器兼容性</li>
<li>操作系统兼容性</li>
</ul>
<h5 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h5><ul>
<li>人工测试<br>测试工程师测试主流浏览器和常用操作系统测试主流程和主界面，看看主流程和主界面是否有问题</li>
<li>第三方测试工具<br>部分情况下，部分浏览器可以依赖第三方工具辅助测试</li>
</ul>
<h5 id="测试选型"><a href="#测试选型" class="headerlink" title="测试选型"></a>测试选型</h5><ul>
<li>Chrome: Webkit内核*1 &amp; Blink内核*1</li>
<li>Firefox: 最新版本</li>
<li>IE: 7-11</li>
<li>Safari: mac版本单独测试</li>
<li>Edge: Window10</li>
<li>360安全浏览器（双核版）</li>
<li>搜狗等其他浏览器任选其一</li>
<li>如有需要Linux系统下Firefox, ChromeOS下Chrome</li>
</ul>
<h5 id="三方工具–IETESTER"><a href="#三方工具–IETESTER" class="headerlink" title="三方工具–IETESTER"></a>三方工具–IETESTER</h5><p>可以进行IE5.5-IE11的兼容性测试，能够满足一定程度的测试需求，但随着IETESTER后期维护乏力，对浏览器的支持不足。同时目前对于IE兼容性来说，更多支持IE7+，我们可以使用IE浏览器自带的调试工具来测试，故IETESTER逐步从重要变成鸡肋</p>
<h5 id="三方工具–BrowserShots"><a href="#三方工具–BrowserShots" class="headerlink" title="三方工具–BrowserShots"></a>三方工具–BrowserShots</h5><p><a href="http://www.browsershots.org/">www.browsershots.org</a> 通过在线截图的方式展现页面的兼容性。限制在于只可以通过输入网址的方式查看，对于还未上线，测试中的网站比较难于使用</p>
<h5 id="三方工具–Super-Preview"><a href="#三方工具–Super-Preview" class="headerlink" title="三方工具–Super Preview"></a>三方工具–Super Preview</h5><p>SuperPreview是微软将推出的Expression Web3的一部分，同时，微软也提供了SuperPreview的独立安装包。他的目标是集成IETESTER和BrowserShots的功能，但是目前还没有完善</p>
<h4 id="APP兼容性测试"><a href="#APP兼容性测试" class="headerlink" title="APP兼容性测试"></a>APP兼容性测试</h4><h5 id="APP兼容性测试方向"><a href="#APP兼容性测试方向" class="headerlink" title="APP兼容性测试方向"></a>APP兼容性测试方向</h5><ul>
<li>硬件设备兼容性</li>
<li>操作系统版本兼容性</li>
</ul>
<h5 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h5><ul>
<li>使用TOP20的机型，指定系统版本</li>
<li>Android机一律要求使用真机或者相应的云服务测试，iOS允许使用模拟器</li>
<li>如果有的TOP20机型无法获取到，允许选取同类（iOS&#x2F;Android）机型作为代替，但最多不超过4个替代机型</li>
</ul>
<h2 id="各项常用测试技术"><a href="#各项常用测试技术" class="headerlink" title="各项常用测试技术"></a>各项常用测试技术</h2><h3 id="白盒测试之代码审查"><a href="#白盒测试之代码审查" class="headerlink" title="白盒测试之代码审查"></a>白盒测试之代码审查</h3><h4 id="代码审查的范围"><a href="#代码审查的范围" class="headerlink" title="代码审查的范围"></a>代码审查的范围</h4><ul>
<li>合格的代码应具备正确性、清晰性、规范性、一致性和高效性</li>
<li>概括起来，代码审查的工作涵盖下列方面<ol>
<li>业务逻辑的审查</li>
<li>算法的效率</li>
<li>代码风格</li>
<li>编程规则</li>
</ol>
</li>
</ul>
<h4 id="代码审查的方法"><a href="#代码审查的方法" class="headerlink" title="代码审查的方法"></a>代码审查的方法</h4><ul>
<li>互查：就是相同模块或相近模块的编程人员之间互相检查对方的代码</li>
<li>走查：从头到尾将写好的程序检查一遍</li>
<li>代码审查</li>
</ul>
<h4 id="代码审查的规则"><a href="#代码审查的规则" class="headerlink" title="代码审查的规则"></a>代码审查的规则</h4><ul>
<li>Java最基本语句的使用</li>
<li>重载函数的审查</li>
<li>内存分配和管理：当进行内存分配和管理时，很重要的一点就是确保内存的及时释放和避免缓冲区溢出</li>
<li>程序性能的审查<ol>
<li>减少创建对象</li>
<li>减少循环体的执行代码，能放在循环体外的代码要尽量放在循环体外</li>
<li>提高处理异常出错的效率</li>
<li>减少I&#x2F;O操作时间</li>
</ol>
</li>
</ul>
<h3 id="白盒测试之逻辑覆盖"><a href="#白盒测试之逻辑覆盖" class="headerlink" title="白盒测试之逻辑覆盖"></a>白盒测试之逻辑覆盖</h3><h4 id="从单元测试说起"><a href="#从单元测试说起" class="headerlink" title="从单元测试说起"></a>从单元测试说起</h4><ul>
<li>单元测试是软件测试中最基础的测试，集成测试、功能测试和系统测试都建立在单元测试之上</li>
<li>单元测试的对象是构成软件产品或系统的最小的独立单元，如封装的类或对象、独立的函数、进程、子过程、组件或模块等</li>
</ul>
<h4 id="单元测试用例设计"><a href="#单元测试用例设计" class="headerlink" title="单元测试用例设计"></a>单元测试用例设计</h4><ul>
<li>对于单元测试用例的设计和程序的实现过程，主要集中在白盒测试方法之上，并力求达到下列测试要求<ol>
<li>对程序模块所有独立的执行路径至少测试一次</li>
<li>对所有逻辑判定，其结果为真、假两种情况至少要测试一次</li>
<li>对程序进行边界检查（常见的如数据越界检验）</li>
<li>检验内部数据结构的有效性</li>
</ol>
</li>
</ul>
<h4 id="逻辑覆盖法"><a href="#逻辑覆盖法" class="headerlink" title="逻辑覆盖法"></a>逻辑覆盖法</h4><ul>
<li>逻辑覆盖法是白盒测试中最主要的测试方法</li>
<li>逻辑覆盖分为语句覆盖、判定覆盖、条件覆盖、判定-条件覆盖、条件组合覆盖，其基本思想不同，产生的测试用例不同，覆盖范围也有所不同</li>
</ul>
<h5 id="语句覆盖"><a href="#语句覆盖" class="headerlink" title="语句覆盖"></a>语句覆盖</h5><p>基本思想：设计若干测试用例，测试被测程序，使程序中每个可执行语句至少被执行一次</p>
<h5 id="语句覆盖的不足"><a href="#语句覆盖的不足" class="headerlink" title="语句覆盖的不足"></a>语句覆盖的不足</h5><p>在使用语句覆盖法进行测试用例设计时，能够使得所有的执行语句都被测试，但是不能准确判断运算中的逻辑关系错误</p>
<h5 id="判定覆盖"><a href="#判定覆盖" class="headerlink" title="判定覆盖"></a>判定覆盖</h5><p>基本思想：是使每个判定的取真值和取假值都至少经历一次</p>
<h5 id="判定覆盖的不足"><a href="#判定覆盖的不足" class="headerlink" title="判定覆盖的不足"></a>判定覆盖的不足</h5><p>有时候个别条件的变化并不会导致多个条件的组合的测试结果发生变化</p>
<h5 id="条件覆盖"><a href="#条件覆盖" class="headerlink" title="条件覆盖"></a>条件覆盖</h5><p>基本思想：是使每个条件的取真值和取假值都至少经历一次</p>
<h5 id="条件覆盖的不足"><a href="#条件覆盖的不足" class="headerlink" title="条件覆盖的不足"></a>条件覆盖的不足</h5><p>保证每个条件至少有一次取真、取假，满足条件覆盖，但是有可能覆盖了相同的路径。说明，即使做到条件覆盖，也不能保证覆盖所有路径</p>
<p>测试用例看似满足更复杂、要求更高的条件覆盖，事实上也不一定能满足判定覆盖的要求</p>
<p>只是满足一种覆盖条件，还会遗漏程序逻辑路径或判定错误，仍旧存在较大风险。所以，白盒测试要求同时满足两种以上的测试覆盖要求，测试的覆盖率能够满足质量要求，将风险降到很低</p>
<h5 id="判定-条件覆盖"><a href="#判定-条件覆盖" class="headerlink" title="判定-条件覆盖"></a>判定-条件覆盖</h5><p>基本思想：确保设计足够精巧的测试用例，可使得判断条件中所有条件的可能取值至少被执行一次，同时，所有判定的可能结果也至少被执行一次</p>
<h5 id="条件组合覆盖"><a href="#条件组合覆盖" class="headerlink" title="条件组合覆盖"></a>条件组合覆盖</h5><p>基本思想：设计足够的测试用例，使判断中每个条件的所有可能至少出现一次，并且每个判断本身的判定结果也至少出现一次。与判定-条件覆盖的差别是，条件组合覆盖不是简单地要求每个条件都出现“真”与“假”两种结果，二是要求让这些结果的所有可能组合都至少出现一次</p>
<h3 id="自动化测试概述"><a href="#自动化测试概述" class="headerlink" title="自动化测试概述"></a>自动化测试概述</h3><p>自动化测试就是把手工测试转化成用机器、软件、程序来测试产品的过程<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/1d5f0bfa19964673a6c3ca14efb0439b.png" alt="自动化测试"></p>
<h4 id="自动化测试的意义"><a href="#自动化测试的意义" class="headerlink" title="自动化测试的意义"></a>自动化测试的意义</h4><ul>
<li>缩短软件开发测试周期，可以让产品更快投放市场</li>
<li>测试效率高，充分利用硬件资源</li>
<li>节省人力资源，降低测试成本</li>
<li>增强测试的稳定性和可靠性</li>
<li>提高软件测试的准确度和精准度，增加软件信任度</li>
<li>软件测试工具使测试工作相对比较容易，但能产生更高质量的测试结果</li>
</ul>
<h4 id="自动化测试应用场景分析"><a href="#自动化测试应用场景分析" class="headerlink" title="自动化测试应用场景分析"></a>自动化测试应用场景分析</h4><ul>
<li>首先要考虑的使什么样的项目适合自动化？决定项目是否采用自动化测试，通常要关注以下几个方面：<ol>
<li>需求变更有计划性，并且频率不高</li>
<li>项目周期长，资源丰富</li>
<li>脚本重复利用率</li>
<li>代码规范</li>
</ol>
</li>
<li>考虑了什么样的项目可以使用自动化，接下来我们要了解的就是在一个项目中，我们也要区分哪些部分适合自动化。<br>某些普遍存在的观点：认为自动化测试更适合回归测试和API测试，手工测试更适合做验收测试和GUI测试<br>正确的观点：什么区分了手工测试和自动化测试，实际上与API还是GUI，回归还是功能都没有关系。应该从代码是业务逻辑相关还是基础性代码出发<br>业务逻辑代码对应终端用户使用的那些功能，是实际完成工作的<br>基础性代码则确保业务逻辑代码运行在合适的环境中起支撑作用而彼此之间相对独立，并不存在业务关系的<br>很明显，两种代码都要测试。手工测试更适合测业务逻辑，因为这部分人类学习起来要比交给自动化容易</li>
</ul>
<h4 id="常用的WEB自动化测试工具"><a href="#常用的WEB自动化测试工具" class="headerlink" title="常用的WEB自动化测试工具"></a>常用的WEB自动化测试工具</h4><h5 id="QTP"><a href="#QTP" class="headerlink" title="QTP"></a>QTP</h5><ul>
<li>QTP是一个侧重于功能的自动化测试工具，提供了很多插件</li>
<li>QTP支持的脚本语言是VBScript，这对于测试人员来说，感觉要“舒服”得多。VBScript毕竟是一种松散的、非严格的、普及面很广的语言</li>
<li>QTP的高可用性：<ol>
<li>支持录制和回放</li>
<li>支持lower level模式</li>
<li>QTP的编辑器支持两种视图：Keyword模式和Expert模式</li>
</ol>
</li>
</ul>
<h5 id="Selenium-WebDriver"><a href="#Selenium-WebDriver" class="headerlink" title="Selenium(WebDriver)"></a>Selenium(WebDriver)</h5><p>用于QTP比较的方式来比较二者的特征和优劣</p>
<ul>
<li>价格<br>Selenium是开源的自动化测试工具，但是QTP是商业版的，而且价格不菲</li>
<li>应用领域<br>Selenium仅支持Web页面的测试，而QTP不光支持Web界面的测试，而且还支持Client方面的测试</li>
<li>功能方面<br>录制功能QTP支持的好。QTP的录制回放成功率很高，Selenium的录制回放成功率非常的低<br>脚本的编辑功能。熟悉Java、Python等的人喜欢Selenium，熟悉的是VBScript可能就会喜欢QTP</li>
<li>框架处理的能力<br>在数据驱动方面，QTP支持很灵活。可以通过简单的设置就可以完成数据驱动的自动化脚本Selenium要用编程来实现才可以</li>
</ul>
<h5 id="UFT-Unified-Functional-Testing"><a href="#UFT-Unified-Functional-Testing" class="headerlink" title="UFT(Unified Functional Testing)"></a>UFT(Unified Functional Testing)</h5><ul>
<li>UFT是QTP的新名字，叫统一功能测试框架。新的功能如下：<ol>
<li>Insight智能图像识别<br>  图像识别一直是我们做自动化测试的障碍之一。包含游戏自动化、Flash动态的一些自动化</li>
<li>多脚本调试</li>
<li>PDF文本验证点<br>  现在UFT可以识别PDF文件并对他们直接进行比较，甚至可以插入文本验证点</li>
<li>支持开源CI</li>
<li>支持移动设备</li>
</ol>
</li>
</ul>
<h5 id="RFT-IBM-Rational-Functional-Tester"><a href="#RFT-IBM-Rational-Functional-Tester" class="headerlink" title="RFT(IBM Rational Functional Tester)"></a>RFT(IBM Rational Functional Tester)</h5><ul>
<li>IBM的一款适合于功能测试、回归测试的自动化测试工具，针对于Java、.Net的对象技术和基于Web应用程序的录制和回放</li>
<li>因为录制于回放功能对于程序运行的环境依赖性太大，因此更多使用该工具的测试团队采用了自己手动写脚本的方式来提高脚本的易读性以及可维护性</li>
<li>框架结构：RFT的脚本可以分别被归类为Appobjects, Tasks和Testcases<ol>
<li>AppObjects: 定义页面上的元素</li>
<li>Tasks: 定义可以单元化，可重用的任务，调用在AppObjects中定义的元素</li>
<li>Testcases: 一个case写成一个脚本，每个测试场景，可以写成一个或多个脚本，每个脚本只调用在Tasks中定义的可重用的任务</li>
</ol>
</li>
<li>RFT结构运行图<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/656847ce6a3f427ea524f6ac01c163c9.png" alt="RFT结构运行图"></li>
<li>为什么这款工具传播和使用范围都不大呢？<ol>
<li>帮助文档和教程很少，很不系统。而提供的API接口只有说明文档，未提供如何使用该文档；提供的例子很少</li>
<li>环境要求比较高，至少得1G内存才能比较顺畅使用，512M内存时比较卡，速度慢</li>
<li>参数化只支持使用XML格式文件来存储测试数据</li>
<li>回放速度极其慢</li>
</ol>
</li>
</ul>
<h5 id="WINRUNNER"><a href="#WINRUNNER" class="headerlink" title="WINRUNNER"></a>WINRUNNER</h5><p>老一代的自动化测试框架，是较早可以录制-回放-修改的自动化测试模式。与QTP类似，也会使用资源库方式存储控件，在06年以前，是测试行业使用最广的自动化测试工具</p>
<h5 id="Sikuli"><a href="#Sikuli" class="headerlink" title="Sikuli"></a>Sikuli</h5><ul>
<li>创新的图形化编程技术<br>Sikuli是由MIT的研究团队发布的新型图形化编程技术。它以图像检索技术为基础，提供了一套基于Jython（Python语言在Java中的完整实现）的脚本语言以及集成开发环境<br>使用者可利用屏幕截图直接引用GUI元素进行编程，完成交互操作</li>
<li>Sikuli脚本<br>Sikuli的脚本编写遵循Python语法规范，其本身提供了多种自定义类及方法<br>Sikuli基于Jython，其核心代码由Java编写</li>
</ul>
<h4 id="自动化测试工具选择"><a href="#自动化测试工具选择" class="headerlink" title="自动化测试工具选择"></a>自动化测试工具选择</h4><ul>
<li>开源免费</li>
<li>使用灵活、简单</li>
<li>后期用例易于维护</li>
<li>支持多种语言</li>
<li>容易与单元测试框架结合</li>
<li>可支持多浏览器同时，支持远程启动其他服务器</li>
<li>高度复用性</li>
<li>代码可自主掌握，对于搭建框架、平台等有不可替代的优势</li>
</ul>
<h3 id="安全测试概述"><a href="#安全测试概述" class="headerlink" title="安全测试概述"></a>安全测试概述</h3><h4 id="Web安全测试介绍"><a href="#Web安全测试介绍" class="headerlink" title="Web安全测试介绍"></a>Web安全测试介绍</h4><h5 id="Web应用的概念"><a href="#Web应用的概念" class="headerlink" title="Web应用的概念"></a>Web应用的概念</h5><ul>
<li>Web应用是由动态脚本、编译过的代码等组合而成</li>
<li>它通常假设在Web服务器上，用户在Web浏览器上发送请求</li>
<li>这些请求使用HTTP协议，由Web应用和企业后台的数据库及其他动态内容通信</li>
</ul>
<h5 id="Web应用三层架构"><a href="#Web应用三层架构" class="headerlink" title="Web应用三层架构"></a>Web应用三层架构</h5><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/7eb97ce992a549fe90973d1e6959b630.png" alt="Web应用三层架构"></p>
<h4 id="日常生活中的“安全”"><a href="#日常生活中的“安全”" class="headerlink" title="日常生活中的“安全”"></a>日常生活中的“安全”</h4><ul>
<li>为什么我们登录的时候经常要求我们输入一个验证码</li>
<li>在一个网站上长时间没有操作，为什么会session失效</li>
<li>为什么支付宝之类的支付接口都是https</li>
</ul>
<h4 id="从WASC和OWASP谈漏洞分类"><a href="#从WASC和OWASP谈漏洞分类" class="headerlink" title="从WASC和OWASP谈漏洞分类"></a>从WASC和OWASP谈漏洞分类</h4><h5 id="WASC-Web-Application-Security-Consortium"><a href="#WASC-Web-Application-Security-Consortium" class="headerlink" title="WASC(Web Application Security Consortium)"></a>WASC(Web Application Security Consortium)</h5><ul>
<li>是一个由安全专家、行业顾问和诸多组织的代表组成的国际团队。他们负责为WWW指定被广为接受的应用安全标准</li>
<li>WASC将Web应用安全威胁分为六大类<ul>
<li>Authentication（验证）：用来确认某用户、服务或是应用身份的攻击手段</li>
<li>Authorization（授权）：用来决定是否某用户、服务或是应用具有执行请求动作必要权限的攻击手段</li>
<li>Client-Side Attacks（客户侧攻击）：用来扰乱或是探测Web站点用户的攻击手段</li>
<li>Command Execution（命令执行）：在Web站点上执行远程命令的攻击手段</li>
<li>Information Disclosure（信息暴露）：用来获取Web站点具体系统信息的攻击手段</li>
<li>Logical Attacks（逻辑性攻击）：用来扰乱或是探测Web应用逻辑流程的攻击手段</li>
</ul>
</li>
</ul>
<h5 id="OWASAP-Open-Web-Application-Security-Project"><a href="#OWASAP-Open-Web-Application-Security-Project" class="headerlink" title="OWASAP(Open Web Application Security Project)"></a>OWASAP(Open Web Application Security Project)</h5><ul>
<li>致力于发现和解决不安全Web应用的根本原因</li>
<li>OWASP Top10 安全漏洞<ul>
<li>注入</li>
<li>失效的身份认证和会话管理</li>
<li>跨站脚本</li>
<li>失效的控制访问</li>
<li>安全配置错误</li>
<li>敏感信息泄露</li>
<li>跨站请求伪造</li>
<li>使用含有已知漏洞的控件</li>
<li>攻击检测和防范不足</li>
<li>未受保护的APIs</li>
</ul>
</li>
</ul>
<h4 id="Web安全测试流程"><a href="#Web安全测试流程" class="headerlink" title="Web安全测试流程"></a>Web安全测试流程</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/9baebe971e1e479ebf0cbd97c5c4625f.png" alt="Web安全测试流程"></p>
<h4 id="安全审计"><a href="#安全审计" class="headerlink" title="安全审计"></a>安全审计</h4><h5 id="自动化审计工具"><a href="#自动化审计工具" class="headerlink" title="自动化审计工具"></a>自动化审计工具</h5><ul>
<li>随着安全测试的开展和深入，越来越多的公司开始采用安全测试的手段，由于测试人员的能力和时间等因素，更多地采取诸如AppScan、WebInspect等安全审计工具</li>
<li>安全审计工具的使用的确给安全测试的开展节省了大量的时间，但同时也带来了各种各样的问题</li>
</ul>
<h5 id="AppScan在项目团队中的协作"><a href="#AppScan在项目团队中的协作" class="headerlink" title="AppScan在项目团队中的协作"></a>AppScan在项目团队中的协作</h5><ul>
<li>开发人员<br>开发人员在开发过程中可以使用AppScan或者专用插件，随时开发随时测试，最大化地保证个人开发程序的安全性。越早发现问题，解决问题的成本就越低，这为Web应用的安全提供了最为坚实的基础保障</li>
<li>测试人员<br>系统测试时测试人员用AppScan对应用做全面的测试，一旦发现问题，可以快速地生成defect，通过CQ集成可以实现defect电子化跟踪，再传递到开发人员手中，指导开发人员迅速解决问题</li>
<li>审核人员<br>这是系统上线前的安全质量关卡。任何系统上线都应该经过严格的上线测试，这也最大化地减少了上线后问题的出现，避免生产系统上线后给企业带来的巨额损失</li>
<li>上线后审计、监控人员<br>上线的系统应该定期检测，一旦出现问题更应该及时检测，越快速地定位发现问题，损失就会越小</li>
</ul>
<h5 id="AppScan扫描范围"><a href="#AppScan扫描范围" class="headerlink" title="AppScan扫描范围"></a>AppScan扫描范围</h5><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/298c92f9a7fe4fab8a3f5e545be50b43.png" alt="AppScan扫描范围"></p>
<h5 id="扫描原理"><a href="#扫描原理" class="headerlink" title="扫描原理"></a>扫描原理</h5><ul>
<li>探测阶段<br>探测过程中，所采用的测试策略可以选择默认的或自定义的，可采用不同的测试策略，测试策略库是AppScan内置的，它可以定义为你想要的组合，去检测你最想检测的可能存在的安全隐患<br>模拟一个用户对被访问的Web应用或Web服务站点进行探测访问，通过发送请求对站点内的链接与表单域进行访问或填写，以获取相应的站点信息（Application Tree）<br>AppScan分析器将会对自己发送的每一个请求后的相应做出判断，查找出任何可能潜在风险的地方，并针对这些可能会隐含风险的下响应，确定将要自动生成的测试用例<br>探测阶段完成后，这些高危区域是否真的隐含着安全缺陷或应做更好的改良，以及这些隐含的风险是处于什么层度的，是需要在测试执行完成后，才能最终得出决论</li>
<li>测试阶段<br>探测阶段后，AppScan已经分析出可能潜在安全风险的站点模型<br>AppScan也已经指导需要生成多少的测试用例，以便检测这些区域的安全隐患。这个时候的工作，主要就是生成这些已经计划好的测试用例<br>AppScan是通过测试策略库中对相应安全隐患的检测规则而生成对应的足够全面而且复杂的测试输入</li>
<li>扫描阶段<br>扫描阶段，AppSsca才是真正地工作起来，它将会把上个阶段的测试用例产生的服务请求陆续地发送出去<br>然后再检测分析服务的响应结果，从而判断该测试用例的输入，是否造成了安全隐患或安全问题<br>然后再通过测试用例生成的策略，找出该安全问题的描述，以及该问题的解决方案，同时还报告相关参数的请求发送和响应结果</li>
</ul>
<h5 id="AppScan工作过程"><a href="#AppScan工作过程" class="headerlink" title="AppScan工作过程"></a>AppScan工作过程</h5><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/4b91f5b1ce564e7cb87e01ae0756880b.png" alt="AppScan工作过程"></p>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><h4 id="性能测试简介"><a href="#性能测试简介" class="headerlink" title="性能测试简介"></a>性能测试简介</h4><ul>
<li>为什么要进行性能测试<ul>
<li>多个客户端同时访问造成压力<ul>
<li>Web应用服务器</li>
<li>应用服务器</li>
<li>数据库</li>
<li>网络</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="性能测试的概念"><a href="#性能测试的概念" class="headerlink" title="性能测试的概念"></a>性能测试的概念</h4><ul>
<li>软件系统的性能测试是一个很大的概念，覆盖面非常广泛<ul>
<li>对软件系统而言，包括执行效率、资源占用、系统稳定性、安全性、兼容性、可靠性、可拓展性</li>
</ul>
</li>
<li>性能测试是描述测试对象与性能相关的特征并对其进行评价而实施和执行的一类测试<ul>
<li>主要通过自动化的测试工具模拟多种正常、峰值以及异常负载条件下来对系统的各项性能指标进行测试</li>
</ul>
</li>
</ul>
<h4 id="性能测试概述"><a href="#性能测试概述" class="headerlink" title="性能测试概述"></a>性能测试概述</h4><ul>
<li>性能测试概述<ul>
<li>性能测试通常包含以下方面的内容<ul>
<li>评估生产准备状态</li>
<li>评估性能判定标准</li>
<li>比较多个不同系统或同一系统不同配置之间的性能特征</li>
<li>找出导致性能问题的源头</li>
<li>帮助进行系统性能调优</li>
<li>确定吞吐量水平</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="性能测试的核心活动"><a href="#性能测试的核心活动" class="headerlink" title="性能测试的核心活动"></a>性能测试的核心活动</h4><ul>
<li>确定测试环境<ul>
<li>物理环境、生产环境、测试团队可利用的工具和资源</li>
</ul>
</li>
<li>确定性能验收标准<ul>
<li>确定响应时间、吞吐量、资料利用总目标和限制</li>
</ul>
</li>
<li>计划和设计测试<ul>
<li>确定关键场景</li>
<li>确定典型用户的可变性，以及如何模拟这些变化</li>
<li>确定测试数据</li>
<li>确定需要收集的度量值</li>
</ul>
</li>
<li>配置测试环境<ul>
<li>随着需要测试的功能和组件的完善，逐步为每个策略准备执行所需的测试环境、工具以及资源</li>
</ul>
</li>
<li>实现测试设计<ul>
<li>根据测试设计逐步展开性能测试</li>
</ul>
</li>
<li>执行测试<ul>
<li>执行和监控测试</li>
</ul>
</li>
<li>分析结果、报告以及重复测试<ul>
<li>整合并共享结果数据</li>
</ul>
</li>
</ul>
<h4 id="性能测试目标"><a href="#性能测试目标" class="headerlink" title="性能测试目标"></a>性能测试目标</h4><ul>
<li>评估软件发布准备<ul>
<li>预测或者估计应用软件在实际生产方面的特性特征，并且基于这些预测来评估是否需要强调性能因素</li>
<li>提供相关数据，反映用户可能会对系统性能特征产生哪些不满意</li>
<li>提供数据帮助预测，由于可伸缩原因和稳定性问题，或者由于用户不满意应用软件的相应时间所导致的收入损失或者品牌可行度降低</li>
</ul>
</li>
</ul>
<h4 id="性能测试介绍"><a href="#性能测试介绍" class="headerlink" title="性能测试介绍"></a>性能测试介绍</h4><ul>
<li>评估基础结构是否恰当<ul>
<li>评估当前容量是否足够</li>
<li>确定稳定性的可接受范围</li>
<li>确定应用软件基础结构的容量</li>
<li>比较不同的系统配置，确定哪些配置可以在实际应用和商业需求之间达到最佳效果</li>
<li>确定应用软件在预计的资源使用限制范围内已经显示出来最佳性能特征</li>
</ul>
</li>
<li>评估已开发软件的性能是否满足要求<ul>
<li>在对应软件进行修改以前和以后，都需要确定应用软件已经获得了满意的性能特征</li>
<li>提供应用软件当前所具有的性能特征与所能达到的最佳性能特征之间的比较</li>
</ul>
</li>
<li>提高性能调整效率<ul>
<li>分析应用软件的各种不同负载水平下的运行状态</li>
<li>确定应用软件的瓶颈</li>
<li>在进行生产发布之前，提供与产生的运行速度、可伸缩性和稳定性相关的信息，这样可以使得相关利益方能够对是否或者何时调整系统做出更加明智的决定</li>
</ul>
</li>
</ul>
<h4 id="性能测试的种类"><a href="#性能测试的种类" class="headerlink" title="性能测试的种类"></a>性能测试的种类</h4><ul>
<li><p>负载测试</p>
</li>
<li><p>压力测试</p>
</li>
<li><p>容量测试</p>
</li>
<li><p>其他</p>
<ul>
<li>配置测试</li>
<li>并发测试</li>
<li>可靠性测试</li>
<li>稳定性测试</li>
<li>…</li>
</ul>
</li>
<li><p>性能测试是确定或者有效验证了系统或者应用软件在测试环境下的速度、可伸缩性以及（或者）稳定性等各种特性</p>
</li>
<li><p>性能是指足以满足项目或者产品的性能目标的相应时间、吞吐量以及资源利用率等</p>
</li>
<li><p>性能测试是一个总体的概念，其他的性格相关的测试都是性能测试的子范畴</p>
</li>
<li><p>负载测试<br>侧重于确定当前测试中的系统或者应用软件在工作负载条件下，或者在实际运行阶段加载预期的容量时，系统或者应用软件所具备的相关性能特性<br>通过逐步增加系统负载，测试系统性能的变化，并最终确定在满足性能指标下，系统所能够承受的最大负载量<br>负载测试是通过逐步加压的方式来确定系统的处理能力，确定系统能够承受的各项阈值</p>
</li>
<li><p>压力测试</p>
<ul>
<li>确定当系统或者应用软件在某些超过实际运行阶段所预期的条件下时所具备的性能特性</li>
<li>通过逐步增加系统负载，测试系统性能的变化，并最终确定在什么负载条件下系统性能，测试系统性能的变化，并最终确定在什么负载条件下系统性能处于失效状态，并获得系统能提供最大的服务基本</li>
<li>压力测试就是逐步增加负载，使系统某些资源达到饱和甚至失效的测试</li>
</ul>
</li>
<li><p>容量测试</p>
<ul>
<li>在满足性能目标的前提下，系统能够最大处理的最大会话能力，确定系统可处理同时在线的最大用户数</li>
<li>容量测试确定了服务器的极限失效点，同时监控在各种不同负载和流量模式水平下的性能结果</li>
</ul>
</li>
<li><p>配置测试</p>
<ul>
<li>通过对被测试软件的软硬件配置的测试，找到系统各项资源的最优分配原则</li>
</ul>
</li>
<li><p>并发测试</p>
<ul>
<li>测试多个用户同时访问同一个应用、同一个模块或者数据记录时是否存在死锁或者其他性能问题，几乎所有的性能测试都会设计一些并发测试</li>
</ul>
</li>
<li><p>可靠性测试</p>
<ul>
<li>通过给系统加载一定的业务压力的情况下，运行一段时间，检查系统是否稳定。通常可以测试出系统是否有内存泄露等问题</li>
</ul>
</li>
<li><p>稳定性测试</p>
<ul>
<li>在复杂多变的环境下系统能够提供的总可靠性、健壮性、功能和数据完整性、有效性以及响应的的连续性</li>
</ul>
</li>
</ul>
<h4 id="核心性能测试活动"><a href="#核心性能测试活动" class="headerlink" title="核心性能测试活动"></a>核心性能测试活动</h4><ol>
<li>确定测试环境</li>
<li>确定性能验收标准</li>
<li>计划和设计测试</li>
<li>配置测试环境</li>
<li>实现测试设计</li>
<li>执行测试</li>
<li>分析结果、报告以及重复测试</li>
</ol>
<table>
<thead>
<tr>
<th align="center">活动</th>
<th align="center">投入</th>
<th align="center">产出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">活动1：确定测试环境</td>
<td align="center">逻辑和物理生产结构、逻辑和物理测试结构、可用工具</td>
<td align="center">测试和生产环境比较、与环境相关的关注点、确定是否需要额外的工具</td>
</tr>
<tr>
<td align="center">活动2：确定性能验收标准</td>
<td align="center">客户预期、可降低的风险、商业需求、合同义务</td>
<td align="center">性能测试成功标准、性能测试目标和需求、调查的关键领域、重要的性能指标、重要的商业活动指标</td>
</tr>
<tr>
<td align="center">活动3：计划和设计测试</td>
<td align="center">可用的应用软件功能和（或者）组件、应用软件的应用场景、部件测试、性能验收标准</td>
<td align="center">总体策略、测试执行的先决条件、所需的工具和资源、将要模拟的应用软件使用模型、执行测试所需要的测试数据、将要执行的测试</td>
</tr>
<tr>
<td align="center">活动4：配置测试环境</td>
<td align="center">总体策略、可用工具、设计好的测试</td>
<td align="center">配置负载生成和资源监督程序、准备性能测试所需环境</td>
</tr>
<tr>
<td align="center">活动5：执行测试设计</td>
<td align="center">总体策略、可用工具和环境、可用应用软件功能和（或者）组件、设计好的测试</td>
<td align="center">有效的、可执行的测试、有效的资源监督、有效的数据采集</td>
</tr>
<tr>
<td align="center">活动6：执行测试</td>
<td align="center">任务执行计划、可用工具和环境、可用的应用软件功能和（或者）组件、有效的、可执行的测试</td>
<td align="center">测试执行结果</td>
</tr>
<tr>
<td align="center">活动7：分析结果、报告和重复测试</td>
<td align="center">任务执行结果、性能验收标准、风险、焦点和问题</td>
<td align="center">结果分析、建议、报告</td>
</tr>
</tbody></table>
<ul>
<li>活动1：确定测试环境<ul>
<li>确定物理环境、生产环境以及测试团队可利用的工具和资源</li>
<li>物理环境包括：硬件、软件以及网络配置</li>
<li>在测试开始时就对整个测试环境有一个全面的了解，可用使得测试设计和计划更加有效，并且有利于在项目初期就确定测试中的复杂问题</li>
</ul>
</li>
<li>活动2：确定性能测试验收标准<ul>
<li>确定响应时间、吞吐量、资源利用总目标以及限制</li>
<li>一般来说，响应时间是用户关系的焦点，吞吐量是业务关系的焦点，资源利用则是系统关系的焦点</li>
<li>确定项目成功的标准，这个标准可能并不包含在上面所确定的总目标和限制之中；例如：利用性能测试来来评估，怎样组合相关的配置才可以带来最佳性能特征</li>
</ul>
</li>
<li>活动3：计划和设计测试<ul>
<li>确定关键场景</li>
<li>确定典型用户的可变性，以及如何模拟这种可变性</li>
<li>确定测试数据</li>
<li>将这些信息整合到一个或多个系统使用情况模型中，以进行实现、执行和分析</li>
</ul>
</li>
<li>活动4：配置测试环境<ul>
<li>随着需要测试的功能和组件的完善，逐步为每个策略准备执行所需要的测试环境、工具以及资源</li>
<li>确保测试环境已经配置妥当吗，可用进行资源监控</li>
</ul>
</li>
<li>活动5：实现测试设计<ul>
<li>根据测试设计逐步展开性能测试</li>
</ul>
</li>
<li>活动6：执行测试<ul>
<li>执行和监控测试</li>
<li>保证测试、测试数据以及结果收集有效</li>
<li>监控测试和测试环境，确保进行有效的测试以保障结果分析的正确性</li>
</ul>
</li>
<li>活动7：分析结果、报告以及重复测试<ul>
<li>整合并且共享结果数据，不仅要对单个数据进行分析，还要从一个功能交叉的测试团队角度来分析数据</li>
<li>如果所有度量都在可接受的范围内，没有违反任何预设阈值，并且收集到了所有需求的信息，就完成了基于特定配置的特定场下的测试</li>
</ul>
</li>
</ul>
<h3 id="LoadRunner"><a href="#LoadRunner" class="headerlink" title="LoadRunner"></a>LoadRunner</h3><ul>
<li>LoadRunner是mercury公司著名的性能测试产品。2006年被HP收购后，LoadRunner就已经成为了Hp重要产品之一</li>
<li>LoadRunner通过模拟一个多用户并行工作的环境来对应用程序进行负载测试。通过最少的硬件资源，这些虚拟用户提供一致的、可重复并可度量的负载，像实际用户一样使用所要测试的应用程序。LoadRunner深入的报告和图提供了评估应用程序性能所需的信息</li>
<li>LoadRunner是一种适用于各种体系架构的负载测试工具，它能预测系统行为并优化系统性能</li>
<li>LoadRunner的测试对象是整个企业的系统，它通过模拟实际用户的操作行为和实行实时性能检测，来帮助你更快地查找和发现问题</li>
<li>LoadRunner能支持广泛的协议和技术，为你的特殊环境提供特殊的解决方案</li>
</ul>
<h4 id="LoadRunner主要特点"><a href="#LoadRunner主要特点" class="headerlink" title="LoadRunner主要特点"></a>LoadRunner主要特点</h4><ul>
<li>广泛支持业界标准协议</li>
<li>支持多种平台开发的脚本</li>
<li>创建真实的系统负载</li>
<li>强大的实时监控与数据采集功能</li>
<li>精确分析结果，定位问题所在</li>
</ul>
<h4 id="LoadRunner工具组成"><a href="#LoadRunner工具组成" class="headerlink" title="LoadRunner工具组成"></a>LoadRunner工具组成</h4><ul>
<li>虚拟用户脚本生成器<br>捕获最终用户业务流程和创建自动化性能测试脚本，即我们在以后说的产生测试脚本</li>
<li>压力产生器<br>通过运行虚拟用户产生实际的负载</li>
<li>用户代理<br>协调不同负载机上虚拟用户，产生步调一致的虚拟用户</li>
<li>压力调度<br>根据用户对场景的设置，设置不同脚本的虚拟用户数量</li>
<li>监视系统<br>监控主要的性能计数器</li>
<li>压力结果分析工具<br>本身不能代替分析人员，但是可以辅助测试结果的分析</li>
</ul>
<h4 id="LoadRunner工作原理"><a href="#LoadRunner工作原理" class="headerlink" title="LoadRunner工作原理"></a>LoadRunner工作原理</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/2d1cb0c866864b28b624838e49a2cc0a.png" alt="LoadRunner工作原理"></p>
<h2 id="手机APP测试"><a href="#手机APP测试" class="headerlink" title="手机APP测试"></a>手机APP测试</h2><h3 id="移动APP的特性"><a href="#移动APP的特性" class="headerlink" title="移动APP的特性"></a>移动APP的特性</h3><ul>
<li>设备<ul>
<li>智能手机</li>
<li>平板电脑</li>
<li>智能手表</li>
</ul>
</li>
<li>网络<ul>
<li>无线（2&#x2F;3&#x2F;4&#x2F;5G)</li>
<li>WiFi</li>
</ul>
</li>
<li>平台<ul>
<li>Android</li>
<li>iOS</li>
</ul>
</li>
</ul>
<h3 id="移动APP的优势"><a href="#移动APP的优势" class="headerlink" title="移动APP的优势"></a>移动APP的优势</h3><ul>
<li>互动性<br>移动设备的触摸屏提供很好的操作体验，APP则提供了更加丰富多彩的表现形式</li>
<li>精准性<br>APP都是用户主动下载的，并且可分享到具有相似兴趣的目标群体</li>
<li>创意性<br>可以结合手机或平板的特性（照相、LBS、重力感应）进行创意性设计及开发，以全新的呈现方式给予用户更好的体验</li>
<li>超强的用户黏性<br>移动时代用户手机通常随身携带，而且上网时间更加碎片化</li>
</ul>
<h3 id="移动APP测试与传统测试的区别"><a href="#移动APP测试与传统测试的区别" class="headerlink" title="移动APP测试与传统测试的区别"></a>移动APP测试与传统测试的区别</h3><ul>
<li>用户关注点<ul>
<li>传统WEB测试<br>屏幕大，可以同时显示信息</li>
<li>移动APP<br>屏幕小，显示信息有限，有价值信息放在主要位置</li>
</ul>
</li>
<li>场景复杂程度<ul>
<li>传统WEB测试<br>地点，网络信号固定</li>
<li>移动APP<br>公交，运动中<br>2&#x2F;3&#x2F;4&#x2F;5G，WiFi，网络不稳定<br>设备电量不足</li>
</ul>
</li>
<li>输入种类<ul>
<li>传统WEB测试<br>键盘，鼠标</li>
<li>移动APP<br>实体键盘，触屏，电容笔，语音</li>
</ul>
</li>
<li>操作尺度<ul>
<li>传统WEB测试<br>点击是一件准确的事情</li>
<li>移动APP<br>触屏的操作尺度就比较大，点击误差大，也不支持hover事件。点击出错几率高</li>
</ul>
</li>
<li>界面布局<ul>
<li>传统WEB测试<br>PC端屏幕宽大，布局可以灵活一些</li>
<li>移动APP<br>移动端屏幕相对窄小，一般是单列，屏幕可以旋转</li>
</ul>
</li>
</ul>
<h3 id="APP测试方法"><a href="#APP测试方法" class="headerlink" title="APP测试方法"></a>APP测试方法</h3><ul>
<li>功能测试</li>
<li>兼容性测试</li>
<li>专项测试</li>
<li>稳定性测试</li>
<li>UI测试</li>
</ul>
<h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><ul>
<li>功能测试<ul>
<li>登录测试<ul>
<li>注册测试<ul>
<li>本地注册</li>
<li>快速注册</li>
</ul>
</li>
<li>登录测试<ul>
<li>多终端登录</li>
<li>第三方登录</li>
</ul>
</li>
<li>注销测试</li>
</ul>
</li>
<li>运行测试</li>
<li>切换测试<ul>
<li>后台切换</li>
<li>删除进程</li>
<li>锁屏</li>
</ul>
</li>
<li>推送测试</li>
<li>更新测试<ul>
<li>手动刷新</li>
<li>自动刷新</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="专项测试"><a href="#专项测试" class="headerlink" title="专项测试"></a>专项测试</h4><h5 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h5><ul>
<li>从不同渠道获取安装程序是否正常安装</li>
<li>软件在不同操作系统下安装是否正常</li>
<li>软件安装后是否能够正常运行，安装后的文件夹及文件是否写到了指定的目录中</li>
<li>软件安装过程是否可以取消，点击取消后，写入的文件是否如概要设计说明处理</li>
<li>软件安装过程中意外情况处理是否符合需求（如死机，重启，断电）</li>
<li>安装空间不足时是否有相应提示</li>
<li>安装后没有生成多余的目录结构和文件</li>
<li>对于需要通过网络验证之类的安装，在断网情况下试一下</li>
<li>还需要对安装手册进行测试，依照安装手册是否能顺利安装</li>
</ul>
<h5 id="卸载测试"><a href="#卸载测试" class="headerlink" title="卸载测试"></a>卸载测试</h5><ul>
<li>直接删除安装文件夹卸载是否有提示信息</li>
<li>测试系统直接卸载程序是否有提示信息</li>
<li>测试卸载后文件是否全部删除所有安装文件夹</li>
<li>卸载过程中出现的意外情况的测试（死机，断电，重启）</li>
<li>卸载是否支持取消功能，单击取消后软件卸载的情况</li>
<li>系统直接卸载UI测试，是否有卸载状态进度条提示</li>
</ul>
<h5 id="交互测试"><a href="#交互测试" class="headerlink" title="交互测试"></a>交互测试</h5><ul>
<li>多个APP同时运行是否影响正常功能</li>
<li>APP运行时前&#x2F;后台切换是否影响正常功能</li>
<li>APP运行时发送&#x2F;收取邮件</li>
<li>APP运行时拨打&#x2F;接听电话</li>
<li>APP运行时发送&#x2F;接收信息</li>
<li>APP运行时切换网络（2&#x2F;3&#x2F;4&#x2F;5G，WiFi）</li>
<li>APP运行时浏览网页</li>
<li>APP运行时使用蓝牙传送&#x2F;接收数据</li>
<li>APP运行时使用相机、计算机、手电筒等手机自带设备</li>
</ul>
<h5 id="升级测试"><a href="#升级测试" class="headerlink" title="升级测试"></a>升级测试</h5><ul>
<li>客户端有新版本是否有更新提示</li>
<li>升级包下载中断是否支持继续或重新下载</li>
<li>升级渠道验证</li>
<li>跨版本升级的可用性</li>
<li>强制升级情况下，用户是否还可以正常使用旧版本</li>
<li>非强制升级情况下，系统对新旧版本的兼容性</li>
</ul>
<h5 id="性能测试（专项测试）"><a href="#性能测试（专项测试）" class="headerlink" title="性能测试（专项测试）"></a>性能测试（专项测试）</h5><ul>
<li>边界测试<br>在各种边界压力下（电量、存储、网络）验证APP可否正确响应</li>
<li>压力测试<br>反复&#x2F;长期操作下，系统资源占用是否异常，APP行为是否正常（自动化）</li>
<li>性能评估<br>在各种典型场景下占用系统资源情况</li>
<li>响应能力测试<br>各类操作是否满足用户可以接收的响应时间要求</li>
<li>消耗测试<br>正常运行时内存，CPU消耗，APP后台长时间运行时耗电量、耗流量</li>
</ul>
<h4 id="UI测试"><a href="#UI测试" class="headerlink" title="UI测试"></a>UI测试</h4><ul>
<li>界面布局<br>布局是否合理，界面是否友好，是否符合用户习惯</li>
<li>图形测试<br>控件方向是否一致，是否可以自适应窗口，标签风格是否统一，图片是否清晰，色彩使用是否让人舒服</li>
<li>内容测试<br>文字表达是否准确，是否有错别字，是否有乱码，是否有敏感词汇，是否侵权</li>
<li>导航测试<br>是否需要导航，导航帮助是否准确直观，导航与页面结构菜单风格是否一致</li>
</ul>
<h3 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a>Appium</h3><h4 id="Appium简介"><a href="#Appium简介" class="headerlink" title="Appium简介"></a>Appium简介</h4><ul>
<li>Appium是一个开源、跨平台的测试框架，可以用来测试原生及混合的移动端应用</li>
<li>Appium支持iOS、Android以及FirefoxOS平台测试</li>
<li>Appium使用WebDriver的底层协议，来驱动Apple系统的UIAutomation库、Android系统的UIAutomator框架</li>
</ul>
<h4 id="Appium特点"><a href="#Appium特点" class="headerlink" title="Appium特点"></a>Appium特点</h4><ul>
<li>跨设备</li>
<li>跨架构</li>
<li>跨语言</li>
<li>跨APP，可以在多个APP之间交互</li>
<li>不依赖源代码</li>
<li>不限制测试架构和平台</li>
</ul>
<h4 id="Appium架构"><a href="#Appium架构" class="headerlink" title="Appium架构"></a>Appium架构</h4><ul>
<li>Android上使用了instrumentation和uiautomator两套技术<ul>
<li>4.1以上使用uiautomator</li>
<li>4.1以下使用selendroid</li>
</ul>
</li>
<li>iOS使用uiautomation</li>
</ul>
<h3 id="APP稳定性-amp-性能测试工具–Monkey"><a href="#APP稳定性-amp-性能测试工具–Monkey" class="headerlink" title="APP稳定性&amp;性能测试工具–Monkey"></a>APP稳定性&amp;性能测试工具–Monkey</h3><ul>
<li>Monkey是Android SDK中自带的工具，运行在模拟设备中，并生成用户事件的伪随机流，例如点击，触摸，或手势，以及若干系统级事件</li>
<li>Monkey测试，所有的事件都是随机产生的，不带任何人的主观性，可使用Monkey进行压力测试</li>
</ul>
<h2 id="软件测试报告"><a href="#软件测试报告" class="headerlink" title="软件测试报告"></a>软件测试报告</h2><ul>
<li>测试报告是把测试的过程和结果写成文档</li>
<li>对发现的问题和缺陷进行分析，为纠正软件存在的质量问题提供依据</li>
<li>同时为软件验收和交付打下基础</li>
<li>测试报告是测试阶段最后的文档产出物</li>
<li>优秀的测试人员应该具备良好的文档编写能力</li>
<li>一份详细的测试报告包含足够的信息，包括产品质量和测试过程的评价</li>
<li>测试报告基础测试中的数据采集以及对最终的测试结果分析</li>
</ul>
<h3 id="测试报告的内容"><a href="#测试报告的内容" class="headerlink" title="测试报告的内容"></a>测试报告的内容</h3><ul>
<li>报告信息<ul>
<li>系统名称</li>
<li>功能名称</li>
<li>报告人</li>
<li>项目经理</li>
<li>报告日期</li>
<li>文档版本</li>
</ul>
</li>
<li>引言<ul>
<li>本测试报告的具体编写目的，指出预期的读者范围<ul>
<li>实例：本测试报告为XXX项目的测试报告，目的在于总结测试阶段的测试以及分析测试结果，描述系统是否符合需求（或达到XXX功能目标）。预期参考人员包括用户、测试人员、开发人员、项目管理者、其他质量管理人员和需要阅读本报告的高层经理</li>
</ul>
</li>
<li>项目背景<ul>
<li>对项目目标和目的进行简要说明</li>
</ul>
</li>
<li>系统简介<ul>
<li>如果设计说明书有此部分，照抄</li>
<li>注意必要的框图和网络拓扑图能吸引眼球</li>
</ul>
</li>
<li>评测产品<ul>
<li>对测试对象的描述</li>
<li>包括但不限于文件&#x2F;程序所在SVN路径，SVN版本号等信息</li>
</ul>
</li>
</ul>
</li>
<li>测试概要<ul>
<li>包括测试的一些声明、测试范围、测试目的等等，主要是测试情况简介</li>
<li>用例设计方法<ul>
<li>简要介绍测试用例的设计方法</li>
<li>例如：等价类、边界值、因果图等</li>
</ul>
</li>
<li>测试环境与配置<ul>
<li>简要介绍测试环境及其配置，可以包含的内容：<ul>
<li>数据库服务器配置、CPU、内存、硬盘可用空间大小、操作系统、应用软件、局域网地址、服务器配置</li>
</ul>
</li>
</ul>
</li>
<li>测试方法与工具<ul>
<li>简要介绍测试中采用的方法和工具<ul>
<li>提示：主要是黑盒测试，测试方法可以写上测试的重点和采用的测试模式工具为可选项，当使用到测试工具和相关工具时，要说明。如LoadRunner, Monkey等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>测试结果与缺陷分析<ul>
<li>主要汇总各种数据并进行度量，度量包括对测试过程的度量和能力评估、对软件产品的质量度量和产品评估</li>
<li>测试执行情况与记录<ul>
<li>描述测试用例执行情况，包括执行的测试用例、通过的测试用例等，记录实验数据</li>
</ul>
</li>
<li>测试组织<ul>
<li>可列出简单的测试组架构图，包括<ul>
<li>测试组架构（如存在分组、用户参与等情况）</li>
<li>测试经理（领导人员）</li>
<li>主要测试人员</li>
<li>参与测试人员</li>
</ul>
</li>
</ul>
</li>
<li>覆盖分析<ul>
<li>需求覆盖率是指经过测试的需求&#x2F;功能和需求规格说明书中所有需求&#x2F;功能的比值，通常情况下要达到100%的目标</li>
<li>测试覆盖：需求&#x2F;功能（或编号） 用例个数 执行总数 未执行 未&#x2F;漏测分析和原因</li>
</ul>
</li>
<li>缺陷分析<ul>
<li>本部分对上述缺陷和其他收集数据进行综合分析</li>
<li>用例质量 &#x3D; 缺陷总数&#x2F;测试用例总数 * 100%</li>
<li>缺陷密度 &#x3D; 缺陷总数&#x2F;功能点总数</li>
<li>测试曲线图<ul>
<li>描述被测系统每工作日&#x2F;周缺陷数情况，得出缺陷走势和趋向</li>
</ul>
</li>
</ul>
</li>
<li>残留缺陷和未解决的问题<ul>
<li>编号：BUG号</li>
<li>缺陷概要：该缺陷描述的事实</li>
<li>原因分析：如何引起缺陷，缺陷的后果，描述造成软件局限性和其他限制性的原因以及未解决的问题</li>
<li>预防和改进措施：弥补手段和长期策略</li>
</ul>
</li>
</ul>
</li>
<li>测试结论与建议<ul>
<li>测试执行是否充分（可以增加对安全性、可靠性、可维护性和性能描述）</li>
<li>是否可以进入下一阶段项目目标</li>
<li>对测试风险的控制措施和成效</li>
<li>测试目标是否完成</li>
<li>测试是否通过</li>
<li>建议<ul>
<li>对系统存在问题的说明，描述测试所揭露的软件缺陷和不足，以及可能给软件实施和运行带来的影响</li>
<li>可能存在的潜在缺陷和后续工作</li>
<li>对缺陷修改和产品设计的建议</li>
<li>对过程改进方面的建议</li>
</ul>
</li>
</ul>
</li>
<li>测试限制</li>
</ul>
<h2 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h2><h3 id="验收测试的主要报告"><a href="#验收测试的主要报告" class="headerlink" title="验收测试的主要报告"></a>验收测试的主要报告</h3><ul>
<li>验收测试是部署软件之前的最后一个测试操作</li>
<li>验收测试的目的是：确保软件准备就绪，并且可以让最终用户将其用于执行软件的既定功能和任务</li>
</ul>
<h3 id="验收测试任务"><a href="#验收测试任务" class="headerlink" title="验收测试任务"></a>验收测试任务</h3><ul>
<li>验收测试是向未来的用户表明系统能够像预定要求那样工作，也就是验收软件的有效性</li>
<li>验收测试的任务，即验证软件的功能和性能如同用户所合理期待的那样</li>
</ul>
<h3 id="验收测试过程"><a href="#验收测试过程" class="headerlink" title="验收测试过程"></a>验收测试过程</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/b2109b461e5c4596b7d296d0c97bba42.png" alt="在这里插入图片描述"></p>
<h3 id="验收测试策略"><a href="#验收测试策略" class="headerlink" title="验收测试策略"></a>验收测试策略</h3><ul>
<li>Alpha测试<ul>
<li>Alpha测试是由用户在开发环境下进行的测试，也可以是开发机构内部的用户在模拟实际操作环境下进行的测试</li>
<li>开发者坐在用户旁边，这是在开发者受控的环境下进行的测试</li>
<li>在系统开发接近完成时对应用系统的测试，测试后仍然会有少量的设计变更，这种测试一般由最终用户或其他人员完成，不能由程序或测试员完成</li>
</ul>
</li>
<li>Beta测试<ul>
<li>Beta测试是由软件的多个用户在一个或多个用户的实际使用环境下进行的测试</li>
<li>开发者通常不在测试环境，这是在开发者无法控制的环境下进行的测试</li>
<li>由用户记录下遇到的所有问题，定期向开发者报告</li>
<li>beta测试是模拟真实的使用环境从而发现缺陷的一种测试</li>
</ul>
</li>
</ul>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>看到任何一个操作的时候，先考虑能不能使用边界值，如果不能使用边界值，就要考虑是否能用等价类。有了等价类之后。后面才会继续考虑如果业务流程比较复杂，可以考虑用因果图，如果业务流程不太复杂，就不太需要因果图。如果是比较复杂的场景，需要使用场景法，或者使用业务流程的方式来进行用例设计</p>
<p>设计业务流程测试（如购物模块），以业务流程、场景法为核心，辅助添加边界值、等价类、因果图 设计方法<br>设计静态功能模块（如登录模块），以边界值、等价类为主要设计方法</p>
<h3 id="测试用例设计–测试方法抉择："><a href="#测试用例设计–测试方法抉择：" class="headerlink" title="测试用例设计–测试方法抉择："></a>测试用例设计–测试方法抉择：</h3><p>输入分类选等价<br>给定范围加边界<br>条件孤立想判定<br>无限穷举取正交<br>业务复杂场景法<br>测试充分全覆盖</p>
<ul>
<li>任何情况下都必须使用边界值分析方法，经验表明用这种方法设计出测试用例发现程序错误的能力最强</li>
<li>必要时用等价类划分方法补充一些测试用例</li>
<li>如果程序的功能说明中含有输入条件的组合情况，则一开始就可选用判定表法</li>
<li>如果程序业务复杂度比较高，则适当使用场景法补充一部分测试用例</li>
</ul>
<h3 id="测试用例综合设计"><a href="#测试用例综合设计" class="headerlink" title="测试用例综合设计"></a>测试用例综合设计</h3><p>e.g. 微信零钱充值</p>
<ol>
<li>边界值考虑充值金额：0元，1元，负数，非金额参数，多位小数（小数后位3位），银行卡限额</li>
<li>等价类考虑多个不同的银行和渠道</li>
<li>由于整体功能尚不包含输入条件的组合情况，所以无需加上因果图</li>
<li>充值完成后，余额将在零钱展示同时包含充值记录<br>  流程-微信唤起充值-充值金额-我的零钱-零钱明细</li>
</ol>
<h3 id="用例评审流程"><a href="#用例评审流程" class="headerlink" title="用例评审流程"></a>用例评审流程</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/c1e47dfea67149f29c5d3ec81a650a32.png" alt="在这里插入图片描述"></p>
<p>冒烟测试：</p>
<ol>
<li>核心流程冒烟 要求100%通过</li>
<li>主流程冒烟（涉及的功能点） 不能超过30%的场景未实现</li>
<li>探索式冒烟： 半小时随机测试 发现bug超过10</li>
</ol>
<p>不符合冒烟通过，就视为不进入测试阶段 测试打回 需要重新提测 重新冒烟</p>
<h3 id="测试缺陷"><a href="#测试缺陷" class="headerlink" title="测试缺陷"></a>测试缺陷</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/03cdf7fef57c4feaa29c3f7877686059.png" alt="在这里插入图片描述"></p>
<p>发现缺陷的境界：（教开发人员写代码）</p>
<ul>
<li>找到问题</li>
<li>找到问题并描述清楚</li>
<li>找到问题，描述清楚并定位问题</li>
<li>找到问题，描述清楚并定位问题且提供解决思路</li>
</ul>
<p>沟通的正确姿势：<br>最好是熟悉基本的开发原理，做到专业、清晰、有条理的表达；站在开发的角度去理解思考问题，同时也要熟悉开发人员的沟通习惯，这样才能做好沟通</p>
<h3 id="测试总结阶段"><a href="#测试总结阶段" class="headerlink" title="测试总结阶段"></a>测试总结阶段</h3><ul>
<li>项目测试情况分析</li>
<li>测试报告与总结</li>
<li>项目测试过程回溯</li>
<li>用户验收测试</li>
<li>使用手册</li>
</ul>
<h3 id="项目上线阶段"><a href="#项目上线阶段" class="headerlink" title="项目上线阶段"></a>项目上线阶段</h3><p>上线前把控 -&gt; 上线前通知上下游系统 -&gt; 特殊情况考量 -&gt; 上线后测试验收 -&gt; 线上问题跟踪 -&gt; 紧急发布测试 -&gt; 持续跟进 -&gt; 补测试用例</p>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body fs14"><div class="line"></div><a id="prev" href="/2022/06/13/Linux-Studying/">Linux_Studying<span class="note">较新</span></a></section></div>






  <div class='related-wrap md reveal' id="comments">
    <div class='cmt-title cap theme'>
      快来参与讨论吧
    </div>
    <div class='cmt-body beaudar'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="beaudar" repo="Fam044/bloghexo-comments" issue-term="pathname" theme="preferred-color-scheme" input-position="top" comment-order="desc" loading="false" branch="main"></div>

    </div>
  </div>



      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
<p>本站由 <a href="https://fam044.github.io/">@Fam044</a> 创建，使用 <a href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0" title="v1.8.0">Stellar</a> 作为主题。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://fastly.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://fastly.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://fastly.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti/umd/heti.min.css","js":"https://unpkg.com/heti/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadBeaudar() {
    const els = document.querySelectorAll("#comments #beaudar");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://beaudar.lipk.org/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
      loadBeaudar();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
