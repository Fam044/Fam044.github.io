<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.2.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://fastly.jsdelivr.net'>
  <link rel="preconnect" href="https://fastly.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>Software_Testing_Learning_Note - Fam044's Blog</title>

  
    <meta name="description" content="以下内容全部来自慕课网课程 《从零开始学测试 一步迈向互联网》，本文仅用于学习整理如有侵权，请联系删除本文 软件测试的发展和职业规划软件测试发展与职业生涯规划 软件测试 技术方向 黑盒测试 白盒测试 自动化测试 性能测试 安全测试 测试架构   管理方向 测试经理 项目经理 SCRUM MASTER   业务方向 测试专家 需求 产品经理 金融等行业精英      软件测试之“独孤九剑” 软件测试">
<meta property="og:type" content="article">
<meta property="og:title" content="Software_Testing_Learning_Note">
<meta property="og:url" content="https://fam044.github.io/2022/06/11/Software-Testing-Learning-Note/index.html">
<meta property="og:site_name" content="Fam044&#39;s Blog">
<meta property="og:description" content="以下内容全部来自慕课网课程 《从零开始学测试 一步迈向互联网》，本文仅用于学习整理如有侵权，请联系删除本文 软件测试的发展和职业规划软件测试发展与职业生涯规划 软件测试 技术方向 黑盒测试 白盒测试 自动化测试 性能测试 安全测试 测试架构   管理方向 测试经理 项目经理 SCRUM MASTER   业务方向 测试专家 需求 产品经理 金融等行业精英      软件测试之“独孤九剑” 软件测试">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/157e96bd89a8454995bcfeb663d8f35a.png">
<meta property="article:published_time" content="2022-06-11T02:55:13.000Z">
<meta property="article:modified_time" content="2022-06-18T06:03:30.741Z">
<meta property="article:author" content="Fam044">
<meta property="article:tag" content="Software Testing">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/157e96bd89a8454995bcfeb663d8f35a.png">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="title" href="/"><div class="main">Fam044's Blog</div></a></div>
<nav class="menu dis-select"></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92"><span class="toc-text">软件测试的发展和职业规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%8F%91%E5%B1%95%E4%B8%8E%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92"><span class="toc-text">软件测试发展与职业生涯规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B9%8B%E2%80%9C%E7%8B%AC%E5%AD%A4%E4%B9%9D%E5%89%91%E2%80%9D"><span class="toc-text">软件测试之“独孤九剑”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%88%B0%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-text">从软件工程到软件测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">软件的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%8D%81%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">软件的十大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">软件的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">软件生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%B8%80%E7%94%9F"><span class="toc-text">软件的一生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="toc-text">软件开发模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%E2%80%93%E5%AD%A6%E4%BC%9A%E5%86%99%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3"><span class="toc-text">软件开发文档–学会写测试文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E8%BF%9B%E7%A8%8B"><span class="toc-text">项目进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5"><span class="toc-text">软件测试概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-text">软件测试方法和分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E7%BB%86%E5%88%86%E9%97%AE%E9%A2%98"><span class="toc-text">性能测试的细分问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-text">生命周期各测试方法对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD"><span class="toc-text">软件测试常见术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B"><span class="toc-text">软件测试常见模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87"><span class="toc-text">软件测试覆盖率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%E7%9A%84%E8%BF%90%E7%94%A8"><span class="toc-text">测试覆盖率的运用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%E7%9A%84%E6%9C%80%E7%BB%88%E6%84%8F%E4%B9%89"><span class="toc-text">测试覆盖率的最终意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87"><span class="toc-text">理解测试覆盖率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E9%9C%80%E8%A6%81%E7%9A%84%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB"><span class="toc-text">软件测试人员需要的知识体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E5%85%B7%E5%A4%87%E7%9A%84%E7%B4%A0%E8%B4%A8"><span class="toc-text">软件测试人员具备的素质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text">软件测试的原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B"><span class="toc-text">软件测试流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8E%9F%E5%88%99"><span class="toc-text">软件测试环境搭建原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">搭建测试环境过程分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-text">测试环境配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E6%A8%A1%E5%BC%8F"><span class="toc-text">Docker模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B9%B3%E5%8F%B0"><span class="toc-text">依赖第三方平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E8%B0%88%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E5%BB%BA%E8%AE%BE%E8%90%BD%E5%9C%B0"><span class="toc-text">浅谈测试环境的建设落地</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%BB%BA%E8%AE%BE%E6%80%9D%E8%B7%AF"><span class="toc-text">环境建设思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B"><span class="toc-text">简单的测试过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E5%88%92%E5%88%86"><span class="toc-text">测试过程划分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%AD%96%E5%88%92%E8%BF%87%E7%A8%8B"><span class="toc-text">测试策划过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E6%B5%8B%E8%AF%95"><span class="toc-text">需求测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">需求测试的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E9%AA%8C%E8%AF%81"><span class="toc-text">需求验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%A3%80%E6%9F%A5%E5%88%97%E8%A1%A8"><span class="toc-text">需求规格说明书检查列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5"><span class="toc-text">测试策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%89%8D%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-text">测试前的思考</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">测试策略是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5%E8%A6%81%E7%B4%A0"><span class="toc-text">测试策略要素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92%E4%B8%8E%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88"><span class="toc-text">测试计划与测试方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5-vs-%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92-vs-%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88"><span class="toc-text">测试策略 vs 测试计划 vs 测试方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E5%88%97%E8%A1%A8"><span class="toc-text">测试方案列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E8%AF%84%E5%AE%A1"><span class="toc-text">测试方案评审</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">软件测试设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">测试设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="toc-text">测试分析和设计的主要任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%B5%8B%E8%AF%95%E6%9D%A1%E4%BB%B6"><span class="toc-text">确定测试条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-text">测试用例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E5%8C%85%E6%8B%AC%E4%BB%A5%E4%B8%8B%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-text">测试用例设计包括以下关键点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E6%A1%88%E4%BE%8B"><span class="toc-text">测试用例案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-text">测试用例常用设计方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E6%B3%95"><span class="toc-text">等价类划分法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E6%96%B9%E6%B3%95"><span class="toc-text">等价类划分方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E7%9A%84%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1"><span class="toc-text">基于等价类划分的用例设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E5%AE%9E%E6%88%98"><span class="toc-text">等价类划分实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">等价类的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">等价类划分要注意的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E6%B3%95"><span class="toc-text">边界值法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-text">边界值分析法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text">边界值设计的原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%9B%BE-amp-%E5%88%A4%E5%AE%9A%E8%A1%A8"><span class="toc-text">因果图&amp;判定表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%9B%BE%E6%B3%95"><span class="toc-text">因果图法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%9B%BE-%E5%88%A4%E5%AE%9A%E8%A1%A8"><span class="toc-text">因果图-判定表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E8%A1%A8"><span class="toc-text">判定表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4%EF%BC%88%E5%9B%A0%E6%9E%9C%E5%9B%BE-amp-%E5%88%A4%E5%AE%9A%E8%A1%A8%EF%BC%89"><span class="toc-text">设计步骤（因果图&amp;判定表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E4%BA%A4%E5%AE%9E%E9%AA%8C%E6%B3%95"><span class="toc-text">正交实验法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E4%BA%A4%E5%AE%9E%E9%AA%8C%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4"><span class="toc-text">正交实验法设计步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E6%AD%A3%E4%BA%A4%E8%A1%A8"><span class="toc-text">如何查找正交表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1"><span class="toc-text">测试场景设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1"><span class="toc-text">场景法基础设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8"><span class="toc-text">用例设计的综合运用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E7%AE%A1%E7%90%86"><span class="toc-text">测试执行管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">测试执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="toc-text">测试执行阶段的主要任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%87%86%E5%85%A5%E5%87%86%E5%87%BA"><span class="toc-text">测试准入准出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%87%86%E5%85%A5%E6%A0%87%E5%87%86"><span class="toc-text">测试准入标准</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%9A%82%E5%81%9C%E3%80%81%E5%81%9C%E6%AD%A2"><span class="toc-text">测试暂停、停止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%87%86%E5%87%BA%E6%A0%87%E5%87%86"><span class="toc-text">测试准出标准</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E7%AE%A1%E7%90%86"><span class="toc-text">缺陷管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7"><span class="toc-text">软件缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7"><span class="toc-text">什么是软件缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">缺陷产生的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E7%8E%B0%E7%BC%BA%E9%99%B7"><span class="toc-text">发现缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E2%80%93%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">缺陷报告–注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BUG%E9%87%8D%E7%8E%B0"><span class="toc-text">BUG重现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E9%87%8D%E7%8E%B0%E7%9A%84BUG"><span class="toc-text">无法重现的BUG</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A"><span class="toc-text">缺陷报告</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E5%8C%85%E5%90%AB%E4%BF%A1%E6%81%AF"><span class="toc-text">缺陷报告包含信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E7%9A%84%E5%86%99%E4%BD%9C%E5%87%86%E5%88%99%EF%BC%885C%EF%BC%89"><span class="toc-text">缺陷报告的写作准则（5C）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E7%9A%84%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84"><span class="toc-text">缺陷报告的组织架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%A0%87%E9%A2%98"><span class="toc-text">缺陷标题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7"><span class="toc-text">缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-text">复现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">缺陷报告注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text">缺陷报告的原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E8%B7%9F%E8%B8%AA"><span class="toc-text">缺陷跟踪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E8%B7%9F%E8%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">缺陷跟踪管理系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%85%E9%81%93%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">禅道项目管理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2"><span class="toc-text">用户角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E4%BD%BF%E7%94%A8"><span class="toc-text">最简使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-text">项目模式基本流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%93%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95"><span class="toc-text">易用性测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%93%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95%E5%86%85%E5%AE%B9"><span class="toc-text">易用性测试内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-text">测试点总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6%E7%B1%BB"><span class="toc-text">控件类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="toc-text">菜单测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%BE%E7%BD%AE"><span class="toc-text">快捷键设置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95"><span class="toc-text">兼容性测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E2%80%93%E5%88%86%E7%B1%BB"><span class="toc-text">兼容性测试–分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E2%80%93%E4%BD%9C%E7%94%A8"><span class="toc-text">兼容性测试–作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Web%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95"><span class="toc-text">Web兼容性测试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Web%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E5%90%91"><span class="toc-text">Web兼容性测试方向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-text">测试方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E9%80%89%E5%9E%8B"><span class="toc-text">测试选型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E2%80%93IETESTER"><span class="toc-text">三方工具–IETESTER</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E2%80%93BrowserShots"><span class="toc-text">三方工具–BrowserShots</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7%E2%80%93Super-Preview"><span class="toc-text">三方工具–Super Preview</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#APP%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95"><span class="toc-text">APP兼容性测试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#APP%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E5%90%91"><span class="toc-text">APP兼容性测试方向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-text">补充说明</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div>


</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/Fam044" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://fastly.jsdelivr.net/gh/cdn-x/placeholder@1.0.3/social/08a41b181ce68.svg"/></a></div></footer>

    </aside>
    <div class='l_main'>
      

      

<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Software-Testing/">Software Testing</a></div><div id="post-meta">发布于&nbsp;<time datetime="2022-06-11T02:55:13.000Z">2022-06-11</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>Software_Testing_Learning_Note</span></h1>
<p><em>以下内容全部来自慕课网课程 <a target="_blank" rel="noopener" href="https://coding.imooc.com/learn/list/411.html">《从零开始学测试 一步迈向互联网》</a>，本文仅用于学习整理<br>如有侵权，请联系删除本文</em></p>
<h2 id="软件测试的发展和职业规划"><a href="#软件测试的发展和职业规划" class="headerlink" title="软件测试的发展和职业规划"></a>软件测试的发展和职业规划</h2><h3 id="软件测试发展与职业生涯规划"><a href="#软件测试发展与职业生涯规划" class="headerlink" title="软件测试发展与职业生涯规划"></a>软件测试发展与职业生涯规划</h3><ul>
<li>软件测试<ul>
<li>技术方向<ul>
<li>黑盒测试</li>
<li>白盒测试</li>
<li>自动化测试</li>
<li>性能测试</li>
<li>安全测试</li>
<li>测试架构</li>
</ul>
</li>
<li>管理方向<ul>
<li>测试经理</li>
<li>项目经理</li>
<li>SCRUM MASTER</li>
</ul>
</li>
<li>业务方向<ul>
<li>测试专家</li>
<li>需求</li>
<li>产品经理</li>
<li>金融等行业精英</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="软件测试之“独孤九剑”"><a href="#软件测试之“独孤九剑”" class="headerlink" title="软件测试之“独孤九剑”"></a>软件测试之“独孤九剑”</h3><ol>
<li>软件测试基础知识<br>最重要的是夯实基础<br>了解测试流程，掌握测试各阶段所需的知识及技能，了解软件生存周期各阶段测试人员的职责</li>
<li>软件测试流程<br>测试流程是每个测试团队的核心，一个完善的流程才能造就一支高效的团队<br>要学习破解软件测试的流程及测试策略、计划、方案的编写与评审过程</li>
<li>软件测试设计<br>我们在开始测试时，并非要一步到位直接攻其核心，上手测试<br>需要从设计入手，这部分主要学习常用的测试需求分析、黑盒测试用例设计方法以及常用测试技术应用等</li>
<li>测试执行管理<br>主要学习测试用例的执行、测试的缺陷管理、跟踪及测试总结，熟悉各种测试文档的撰写</li>
<li>功能测试项目实践<br>将前面讲解的测试方法串联起来</li>
<li>测试技术深化<br>从自动化、性能、安全以及白盒测试方法的测试手段和方法，对软件测试技术进行进一步深化</li>
<li>手机APP测试<br>学习APP测试与WEB测试的不同点，常见的测试点，弱网、兼容性测试模式，并初步介绍APP自动化测试实现方法</li>
<li>测试总结<br>对测试过程及进行一个总结，有产出才是整个测试的总结</li>
<li>面试秘籍</li>
</ol>
<h2 id="从软件工程到软件测试"><a href="#从软件工程到软件测试" class="headerlink" title="从软件工程到软件测试"></a>从软件工程到软件测试</h2><h3 id="软件的概念"><a href="#软件的概念" class="headerlink" title="软件的概念"></a>软件的概念</h3><p>软件是计算机系统中与硬件相互依存的另一部分，它是包括程序，数据及其相关文档的完整集合<br>程序 是按实现设计的功能和性能要求执行的指令序列<br>数据 是使程序能正常操纵信息的数据结构<br>文档 是与程序开发，维护和使用有关的图文材料</p>
<h3 id="软件的十大特性"><a href="#软件的十大特性" class="headerlink" title="软件的十大特性"></a>软件的十大特性</h3><ol>
<li>形态特性<br>软件是无形的、不可见的逻辑实体。度量常规产品的几何尺寸、物理性质和化学成分对它却是毫无意义的</li>
<li>智能特性<br>软件是复杂的智力产品，它的开发凝聚了人们大量的脑力劳动，它本身也体现了知识实践经验和人类的指挥，具有一定的智能。它可以帮助我们解决复杂的计算、分析、判断和决策问题</li>
<li>开发特性<br>尽管已经有了一些工具（也是软件）来辅助软件开发工作，但到目前为止尚未实现自动化。软件开发中仍然包括了相当分量的个体劳动，使得这一大规模知识型工作充满了个人行为和个人因素</li>
<li>质量特性<br>软件是由人编写的，由于其开发特性存在，所以不存在完全没有缺陷的软件</li>
<li>生产特性<br>与硬件或传统的制造业商品的生产完全不同，软件一旦设计开发出来，如果需要提供多个用户，它的复制十分简单，其成本也极为有限</li>
<li>管理特性<br>由于上面的特性存在，所以软件过程中的管理显得更为重要，相比传统行业，也更为独特</li>
<li>环境特性<br>软件的开发与运行都离不开相关的计算机系统环境，包括支持它的开发和运行相关的硬件和软件。软件对于计算机系统的环境有着不可摆脱的依赖性</li>
<li>维护特性<br>软件投入使用后需要进行维护，但这种维护与传统产业产品的维护概念有着很大差别，维护体现在升级、优化、功能更新等方面，甚至可以全盘重构</li>
<li>废弃特性<br> 与硬件不同，软件并不是被“用坏”而是被废弃的</li>
<li>应用特性<br>软件的应用极为广泛，如今它已渗入国民经济和国防的各个领域，现已成为信息产业、先进制造业和服务业的核心，占据了无可取代的地位</li>
</ol>
<h3 id="软件的分类"><a href="#软件的分类" class="headerlink" title="软件的分类"></a>软件的分类</h3><ol>
<li>系统软件<br>系统软件是负责管理计算机系统中各种独立的硬件，使得它们可以协调工作<ul>
<li>服务型程序：如诊断程序、排错程序、练习程序等</li>
<li>语言程序：如汇编程序、编译程序、解释程序</li>
<li>操作系统</li>
<li>数据库管理系统</li>
</ul>
</li>
<li>应用软件<br>应用系统是为了某种特定的用途而被开发的软件，它可以是一个特定的程序，比如一个图像浏览器，也可以是一组功能联系紧密，可以互相协作的程序的集合</li>
</ol>
<h3 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h3><p>软件的生命周期，又称为软件的生存周期。它是按开发软件的规模和复杂程度，从时间上把软件开发的整个过程（从计划开发开始到软件报废为止的整个历史阶段）进行分解，形成相对独立的几个阶段<br>每个阶段又分解成几个具体的任务，然后按规定顺序依次完成各阶段的任务并规定一套标准的文档作为各个阶段的开发成果，最后生产出高质量的软件</p>
<h3 id="软件的一生"><a href="#软件的一生" class="headerlink" title="软件的一生"></a>软件的一生</h3><p>问题定义 -&gt; 可行性研究 -&gt; 需求分析 -&gt; 概要设计 -&gt; 详细设计 -&gt; 编码和单元测试 -&gt; 综合测试 -&gt; 软件维护</p>
<p>e.g. 余额宝的诞生</p>
<p>问题定义：普惠金融与互联网金融的融合 -&gt; 可行性研究：T+0是否可以实现；是否合规 -&gt; 需求分析：细分 story -&gt; 概要设计 -&gt; 详细设计 -&gt; 编码和单元测试 -&gt; 综合测试 -&gt; 软件维护</p>
<h3 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h3><p>由于项目、需求的模式不同，所以在软件生命周期过程中选择的软件开发模型也会有所不同，在历史上，软件开发模型经历了“边做边改”、瀑布、原型、螺旋、敏捷等模式的变更</p>
<ul>
<li><p>瀑布模型<br>计划 -&gt; 需求分析 -&gt; 设计 -&gt; 编码 -&gt; 测试 -&gt; 运行维护</p>
<p>特点：</p>
<ol>
<li>软件开发的各项活动严格按照线性方式进行</li>
<li>当前活动接受上一项活动的工作结果</li>
</ol>
<p>缺点：</p>
<ol>
<li>由于开发模型是线性的，增加了开发的风险</li>
<li>早期的错误可能要等到开发后期的阶段才能发现</li>
</ol>
</li>
<li><p>原型模型<br>客户与开发公司紧密联系，开发周期长。开发会受到需求变更的影响</p>
<p>特点：</p>
<ol>
<li>实现客户与系统的交互</li>
<li>进一步细化待开发软件需求</li>
<li>开发人员可以确定客户的真正需求是什么</li>
</ol>
</li>
<li><p>螺旋模型<br>制定计划 -&gt; 风险分析 -&gt; 实施工程（需求确认、软件需求、软件产品设计、设计确认与认证、详细设计、开发、测试） -&gt; 客户评估</p>
<p>特点：</p>
<ol>
<li>螺旋模型是将瀑布模型与快速原型模型结合起来</li>
<li>强调了其他模型所忽视的风险分析</li>
<li>每一次螺旋包括4个步骤：制定计划、风险分析、实施工程、客户评估</li>
</ol>
<p>缺点：</p>
<ol>
<li>强调风险分析，但要求许多客户接受并相信这种分析，是不容易的</li>
</ol>
</li>
<li><p>敏捷模型<br>敏捷开发是一种以人为核心、迭代、循序渐进的开发方法</p>
<p>特点：</p>
<ol>
<li>短周期开发</li>
<li>增量开发</li>
<li>由程序员和测试人员编写的自动化测试来监控开发进度</li>
<li>通过口头沟通、测试和源代码来交流系统的结构和意图</li>
<li>编写代码之前先写测试代码，也叫做测试先行</li>
</ol>
<p>缺点：</p>
<ol>
<li>团队的组建较难，人员素质要求较高</li>
<li>对测试员要求完全掌握各种脚本语言编程，能执行单元测试、自动化测试</li>
</ol>
</li>
</ul>
<h3 id="软件开发文档–学会写测试文档"><a href="#软件开发文档–学会写测试文档" class="headerlink" title="软件开发文档–学会写测试文档"></a>软件开发文档–学会写测试文档</h3><p>需求分析文档 -&gt; 概要设计文档 -&gt; 详细设计文档 -&gt; 测试设计文档 -&gt; 测试用例 -&gt; 测试报告</p>
<h3 id="项目进程"><a href="#项目进程" class="headerlink" title="项目进程"></a>项目进程</h3><ul>
<li>编程阶段-单元（白盒）<br>测试参与</li>
<li>编程完成-开发联调（集成测试）<br>开发为主</li>
<li>提测-冒烟测试（自动化为主，手工为辅）<br>测试执行</li>
<li>测试阶段-系统测试（黑盒功能测试为主，自动化&#x2F;接口测试为辅，根据项目进行性能、安全测试）</li>
<li>验收阶段-验收测试<br>测试配合用户或需求</li>
</ul>
<h3 id="软件测试概念"><a href="#软件测试概念" class="headerlink" title="软件测试概念"></a>软件测试概念</h3><ul>
<li>经典定义：<br>软件测试（Software Testing），在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程</li>
<li>标准定义：<br>软件测试是使用人工或自动的手段来运行或测定某个软件系统的过程，其目的是在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别</li>
<li>软件测试目的：<br>软件测试目的在于发现问题，检查系统是否满足需求</li>
</ul>
<h3 id="软件测试方法和分类"><a href="#软件测试方法和分类" class="headerlink" title="软件测试方法和分类"></a>软件测试方法和分类</h3><ul>
<li>软件测试分类<ul>
<li>按生命周期划分<ul>
<li>单元测试</li>
<li>冒烟测试</li>
<li>集成测试</li>
<li>系统测试</li>
<li>验收测试</li>
</ul>
</li>
<li>按测试方法划分<ul>
<li>白盒测试<ul>
<li>静态分析</li>
<li>动态分析<ul>
<li>逻辑覆盖测试<ul>
<li>语句覆盖</li>
<li>判定覆盖</li>
<li>条件覆盖</li>
<li>路径覆盖</li>
</ul>
</li>
<li>插桩测试</li>
</ul>
</li>
</ul>
</li>
<li>黑盒测试<ul>
<li>功能测试<ul>
<li>界面测试</li>
<li>冒烟测试</li>
<li>回归测试</li>
<li>业务测试</li>
<li>兼容性测试</li>
<li>易用性测试</li>
</ul>
</li>
<li>自动化测试<ul>
<li>WEB自动化测试</li>
<li>接口自动化测试</li>
</ul>
</li>
<li>性能测试<ul>
<li>性能测试</li>
<li>负载测试</li>
<li>压力测试</li>
<li>容量测试</li>
<li>并发测试</li>
<li>持久性测试</li>
</ul>
</li>
<li>安全测试<ul>
<li>手动操作</li>
<li>自动化审计</li>
</ul>
</li>
</ul>
</li>
<li>灰盒测试</li>
</ul>
</li>
<li>其他<ul>
<li>随机测试</li>
<li>探索性测试</li>
<li>α测试</li>
<li>β测试</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="性能测试的细分问题"><a href="#性能测试的细分问题" class="headerlink" title="性能测试的细分问题"></a>性能测试的细分问题</h3><ol>
<li>性能测试：性能测试通常泛指所有类型的性能测试，目标是在特定条件下验证软件系统的性能是否达到预期指标的结果。</li>
<li>负载测试：负载测试是指模拟真实的用户行为，通过不断加压直到系统性能测试瓶颈或资源达到饱和。负载测试是最常进行的性能测试，用于测量系统的容量，发现系统瓶颈并配合性能调优。</li>
<li>压力测试：压力测试是指测试系统在一定的饱和状态下系统的处理能力。在负载测试的基础上，继续不断加压到一定阶段。通过压力测试通过CPU使用率达到75%以上或者内存使用率达70%以上（具体的压力指标也可以是数据库达到相关指标，或者中间件连接数达到某种指标等等），用于测试系统在压力环境下的稳定性。<br>注：许多开发人员提出测试申请，说要做一个压力测试，做为专业的性能测试人员，那么需要明确测试需求，开发人员说的压力测试，往往不是真正意义上的压力测试</li>
<li>可靠性测试：可靠性测试是指加载一定的业务压力，同时让压力持续运行一段时间，测试系统是否可以稳定运行。</li>
<li>并发测试：并发测试是模拟用户在访问同一应用的测试，用于发现并发问题，例如线程锁、资源争用、数据库死锁等。</li>
<li>配置测试：配置测试是指验证各种配置对系统性能的影响，常用于性能调优和能力规划。</li>
<li>疲劳强度测试：在系统稳定运行情况下，以能够支持的最大并发用户数或日常运行用户数，持续执行业务操作一段时间，通过综合分析交易执行指标和资源监控指标，来确定系统处理最大工作强度的性能表现。</li>
<li>大数据量测试：大数据量测试侧重点在于数据的量上，包括独立的数据量测试和综合数据量测试。独立的数据量测试可以理解为某些系统存储、传输、统计、查询等业务进行大数据量测试，而综合数据量测试一般和压力测试、负载测试、疲劳强度测试相结合进行。</li>
</ol>
<h3 id="生命周期各测试方法对比"><a href="#生命周期各测试方法对比" class="headerlink" title="生命周期各测试方法对比"></a>生命周期各测试方法对比</h3><table>
<thead>
<tr>
<th></th>
<th>单元测试</th>
<th>集成测试</th>
<th>冒烟测试</th>
<th>系统测试</th>
<th>验收测试</th>
</tr>
</thead>
<tbody><tr>
<td>测试阶段</td>
<td>编码后</td>
<td>单元测试完成后</td>
<td>提测后</td>
<td>冒烟测试通过后</td>
<td>发布前</td>
</tr>
<tr>
<td>测试对象</td>
<td>最小模块</td>
<td>模块间的接口</td>
<td>整个系统</td>
<td>整个系统</td>
<td>整个系统</td>
</tr>
<tr>
<td>测试人员</td>
<td>白盒测试或开发</td>
<td>白盒测试或开发</td>
<td>黑盒测试</td>
<td>黑盒测试</td>
<td>最终用户或需求方</td>
</tr>
<tr>
<td>测试依据</td>
<td>代码、注释、详细设计文档</td>
<td>单元测试模块、概要设计模块</td>
<td>冒烟测试用例</td>
<td>需求说明文档、测试方案、测试用例</td>
<td>用户需求、验收标准</td>
</tr>
<tr>
<td>测试方法</td>
<td>白盒测试</td>
<td>黑盒与白盒结合</td>
<td>黑盒测试（手工或与自动化结合）</td>
<td>黑盒测试</td>
<td>黑盒测试</td>
</tr>
</tbody></table>
<h3 id="软件测试常见术语"><a href="#软件测试常见术语" class="headerlink" title="软件测试常见术语"></a>软件测试常见术语</h3><ul>
<li>缺陷(Bug&#x2F;Defect)<br>软件的Bug指的是软件中（包括程序和文档）不符合用户需求的问题</li>
<li>测试环境<br>软件测试环境就是软件运行的平台，包括软件、硬件和网络的集合，用一个等式来表示： 测试环境&#x3D;软件+硬件+网络</li>
<li>测试用例(Test Case)<br>在测试执行之前设计的一套详细的测试方案，包括测试环境、测试步骤、测试数据和预期结果<br>用一个等式来简单表示：测试用例&#x3D;输入+输出+测试环境<br>其中，“输入”包括测试数据和操作步骤，“输出”指的是期望结果，“测试环境”指的是系统环境设置</li>
<li>冒烟测试(Smoke Testing)<br>在对一个新版本进行系统大规模地测试之前，先验证一下软件的基本功能是否实现，是否具备可测性</li>
<li>α测试<br>验收测试的一种，指的是由用户、测试人员、开发人员等共同参与的内部测试</li>
<li>β测试<br>验收测试的一种，指的是内测后的公测，即完全交给最终用户测试</li>
</ul>
<h3 id="软件测试常见模型"><a href="#软件测试常见模型" class="headerlink" title="软件测试常见模型"></a>软件测试常见模型</h3><ul>
<li><p>V模型<br>V模型是我们熟知的瀑布模型的一种改进，瀑布模型将软件生命周期划分为计划、分析、设计、编码、测试和维护六个阶段，由于前期的错误可能要等到开发后期的测试阶阶段才能发现，所以可能带来严重的后果<br>V模型就是在这点改进了瀑布模型，在软件开发的生存期，开发活动和测试活动几乎同时开始，这两个并行的动态的过程就会极大的减少bug和error出现的几率</p>
</li>
<li><p>W模型<br>一些高性能高风险的系统、互联网软件，或一个系统难以被具体模块化的时候，就比较难做成V模式所需的各种构建，需要更强调迭代的开发模型或者敏捷开发模型<br>W模型从V模型演化过来，实际上开发是V，测试是并行的V；相对于V模型，W模型增加了软件各开发阶段中应同步进行的验证和确认活动，W明确表示出了测试与开发的并行关系。测试与开发是同步进行的，有利于尽早地全面地发现问题</p>
</li>
<li><p>H模型<br>真正的测试级别之间不存在严格的次序关系，各阶段间可以反复出发、迭代、增量<br>为了解决V模型和W模型存在的问题，有专家提出了H模型。它将测试活动完全独立出来，形成一个完全独立的流程，将测试准备活动和测试执行活动清晰地体现出来</p>
</li>
<li><p>X模型</p>
</li>
</ul>
<h3 id="软件测试覆盖率"><a href="#软件测试覆盖率" class="headerlink" title="软件测试覆盖率"></a>软件测试覆盖率</h3><ul>
<li><p>测试覆盖率<br>覆盖率是用来度量测试完整性的一个手段，同时也是测试技术有效性的一个度量<br>覆盖率 &#x3D; （至少被执行一次的item数）&#x2F;item的总数</p>
<p>特点：</p>
<ol>
<li>通过覆盖率数据，可以检测我们的测试是否充分</li>
<li>分析出测试的弱点在哪方面</li>
<li>指导我们设计能够增加覆盖率的测试用例，有效提高测试质量，但是测试用例设计不能一味追求覆盖率，因为测试成本随覆盖率的增加而增加</li>
</ol>
<p>测试覆盖率对于黑盒测试来说，主要指两个方面： 需求覆盖 和 用例覆盖</p>
<ul>
<li>需求覆盖<ol>
<li>定义：它表示在测试中，有哪些函数被测试到了，其被测试到的频率有多大，这些函数在系统所有函数中占的比例有多大通过设计一定的测试用例，要求每个需求点都被测试到</li>
<li>计算公式：需求覆盖 &#x3D; （被验证到的需求数量）&#x2F;（总的需求总数）</li>
</ol>
</li>
<li>用例覆盖<ol>
<li>定义：主要体现在我们每轮测测试验证通过的用例在总用例中的比重</li>
<li>计算公式：用例覆盖 &#x3D; （验证通过的用例数量）&#x2F;（总的用例总数）</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="测试覆盖率的运用"><a href="#测试覆盖率的运用" class="headerlink" title="测试覆盖率的运用"></a>测试覆盖率的运用</h3><ul>
<li>简单的测试覆盖率<br>本次测试执行的用例数&#x2F;所有用例数<br>上述覆盖率统计建立在认为总用例数编写全面，一般对于大型系统要求覆盖率100%<br>覆盖率的审核：抽样验收</li>
<li>基于产品的测试覆盖率<br>已测试需求点&#x2F;设计所有需求数<br>以产品、需求维度统计，无论大型项目或是小需求迭代都要求覆盖率达到100%<br>覆盖率的审核：抽样验收</li>
<li>基于白盒的测试覆盖率<br>大多工具判断语句覆盖，即单元测试代码覆盖代码行&#x2F;总代码行<br>更多考察研发人员；更多时候要求覆盖率达到80+%<br>缺陷：覆盖率数据只能代表测试过哪些代码，不能代表是否测试好哪些代码；容易遗漏逻辑、判断等场景</li>
<li>基于自动化的测试覆盖率<br>自动化覆盖的测试场景（测试用例）&#x2F;所有测试场景（用例）<br>80&#x2F;20原则，比如用户80%的时间在使用20%的功能，20%的功能就可以支撑起用户最关键的业务场景，自动化测试的用例选择更注重于这20%的核心功能<br>用途：自动化测试更着重于回归验证，没必要追求过高的覆盖率，而要考虑用例设计</li>
</ul>
<h3 id="测试覆盖率的最终意义"><a href="#测试覆盖率的最终意义" class="headerlink" title="测试覆盖率的最终意义"></a>测试覆盖率的最终意义</h3><p>应用最多的地方在测试停止标准</p>
<p>单纯讨论测试覆盖率，在瀑布式开发模型中并不重要，但在螺旋式、敏捷开发模型中由于不断迭代累加，很难确定哪些模块在开发过程中没有给予足够的测试</p>
<p>在短迭代、DevOps中，更强调用单元测试覆盖率来评估不断增加的代码数量</p>
<h3 id="理解测试覆盖率"><a href="#理解测试覆盖率" class="headerlink" title="理解测试覆盖率"></a>理解测试覆盖率</h3><p>我们学习了测试覆盖率的两种统计方式，一种是需求覆盖率，一种是需求覆盖率，那你是怎么理解这两种覆盖率之间的联系的？比如说：是根据不同的覆盖率规则，来设计不同维度的测试用例么？还是根据不同的需求，选择性的进行测试？或者？</p>
<p>这是我们统计的两种方式，跟我们设计用例没有关系，是统计执行的。</p>
<p>可以这么来理解，我们假设这次项目有100个需求，你根据需求设计了5000条用例，执行了4800条用例，覆盖了99个需求。</p>
<p>那么需求覆盖率就是99%，用例覆盖率就是96%。</p>
<p>测试的工作内容没有变化，只是统计方式有差别。</p>
<h3 id="软件测试人员需要的知识体系"><a href="#软件测试人员需要的知识体系" class="headerlink" title="软件测试人员需要的知识体系"></a>软件测试人员需要的知识体系</h3><ul>
<li>软件测试基础知识</li>
<li>软件测试流程</li>
<li>测试用例设计方法</li>
<li>兼容性测试&#x2F;易用性测试</li>
<li>缺陷管理</li>
<li>测试工具使用</li>
<li>测试文档编写</li>
<li>……</li>
</ul>
<h3 id="软件测试人员具备的素质"><a href="#软件测试人员具备的素质" class="headerlink" title="软件测试人员具备的素质"></a>软件测试人员具备的素质</h3><ul>
<li>踏实细心</li>
<li>积极主动</li>
<li>好奇心，怀疑一切</li>
<li>良好交流能力</li>
<li>自我提高和总结能力</li>
<li>责任感</li>
<li>……</li>
</ul>
<h3 id="软件测试的原则"><a href="#软件测试的原则" class="headerlink" title="软件测试的原则"></a>软件测试的原则</h3><ul>
<li>所有的测试都应追溯到用户需求<br>“产品缺陷的80%以上是产品开发过程中的需求定义阶段引入的，如果需求得到了准确的验证，则可以消除80%的返工问题，节省总项目投入费用的45%”</li>
<li>尽早启动测试工作</li>
<li>Pareto法则应用于软件测试<br>Pareto法则是由意大利经济学家Pareto提出的，又称为28效率法则<br>测试中的Pareto法则是说一般情况下，在分析、设计、实现阶段的复审和测试工作能够发现和避免80%的缺陷，而系统测试又能找出其余缺陷中的80%，最后4%的缺陷可能只有在用户的大范围、长时间使用后才会暴露出来</li>
<li>穷尽测试是不可能的<br>由于很少有机会对一个应用软件进行所有可能的测试，对大多数软件开发项目来说，利用风险分析是适当的。这需要判断技能、常识、感觉和经验。如果有正当理由，也可采用正式的方法</li>
<li>杀虫剂怪事<br>软件测试越多，其对测试的免疫力越强的现象<br>为了克服杀虫剂怪事，软件测试员必须不断编写不同的、新的测试程序，对程序的不同部分进行测试，以找出更多软件缺陷</li>
<li>前进两步，后退一步<br>测试中的一个基本问题是–缺陷修复总会以（20-50）%的几率引入新的缺陷</li>
<li>三心二意<br>细心、信心、耐心<br>团队合作的沟通意识、时刻保持怀疑的态度且有缺陷预防意识</li>
</ul>
<h2 id="软件测试流程"><a href="#软件测试流程" class="headerlink" title="软件测试流程"></a>软件测试流程</h2><h3 id="软件测试环境搭建原则"><a href="#软件测试环境搭建原则" class="headerlink" title="软件测试环境搭建原则"></a>软件测试环境搭建原则</h3><ul>
<li>搭建测试环境前<ul>
<li>确定测试目的<ul>
<li>功能测试，稳定性测试，还是性能测试，测试目的不同，搭建测试环境时应注意的点也不同</li>
<li>功能测试：不需要大量的数据，需要覆盖率高，测试数据要求尽量真实</li>
<li>性能测试：可能需要大量存量数据或者与实际硬件环境尽可能相似的硬件配置</li>
</ul>
</li>
<li>测试的软件环境尽可能的模拟真实环境<ul>
<li>尽可能地模拟用户使用环境，选用合适的操作系统和软件平台</li>
<li>了解符合测试软件运行的最低要求及用户使用的硬件配置</li>
<li>了解用户常用的软件，避免所有配置所有操作系统下都要进行测试，没有侧重点，浪费时间</li>
<li>产品化的测试则需要考虑兼容性的方案</li>
</ul>
</li>
<li>营造独立的测试环境<ul>
<li>不同的项目、不同的公司会对测试环境的独立性有不同的要求</li>
<li>测试过程中尽量保证测试环境独立，不受其他测试人员以及项目研发人员的影响</li>
</ul>
</li>
<li>构建可复用的测试环境<ul>
<li>通过备份或数据隔离的方式</li>
<li>重复运用一套测试环境进行多版本多时间段的测试</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="搭建测试环境过程分析"><a href="#搭建测试环境过程分析" class="headerlink" title="搭建测试环境过程分析"></a>搭建测试环境过程分析</h3><ul>
<li>线下搭建<ul>
<li>独立测试服务器或虚拟机</li>
<li>测试环境配置</li>
<li>测试项目导入</li>
</ul>
</li>
</ul>
<h3 id="测试环境配置"><a href="#测试环境配置" class="headerlink" title="测试环境配置"></a>测试环境配置</h3><ul>
<li>配置java环境（下载jdk并配置环境变量）</li>
<li>下载并安装中间件（tomcat、jetty或其他）</li>
<li>安装数据库并导入初始化脚本</li>
</ul>
<h3 id="Docker模式"><a href="#Docker模式" class="headerlink" title="Docker模式"></a>Docker模式</h3><ul>
<li>构建属于自己的image</li>
<li>一键deploy</li>
</ul>
<h3 id="依赖第三方平台"><a href="#依赖第三方平台" class="headerlink" title="依赖第三方平台"></a>依赖第三方平台</h3><ul>
<li>依赖第三方平台（如蚂蚁金融云）</li>
</ul>
<h3 id="浅谈测试环境的建设落地"><a href="#浅谈测试环境的建设落地" class="headerlink" title="浅谈测试环境的建设落地"></a>浅谈测试环境的建设落地</h3><h4 id="环境建设思路"><a href="#环境建设思路" class="headerlink" title="环境建设思路"></a>环境建设思路</h4><ul>
<li>考虑点：用途、使用成本、维护成本</li>
<li>基本架构<ul>
<li>研发环境：用于研发自测、集成测试</li>
<li>测试环境：用于日常单系统或两两微服务之间测试，可同时集成自动化测试回归</li>
<li>联测环境：完备环境，用于大型联测</li>
<li>外联环境（如果有需求）：稳定版本环境，用于外部商户等联调</li>
<li>灰度&#x2F;沙箱环境：用于生存数据测试，仿真测试</li>
</ul>
</li>
</ul>
<h4 id="简单的测试过程"><a href="#简单的测试过程" class="headerlink" title="简单的测试过程"></a>简单的测试过程</h4><p>制定测试计划 -&gt; 设计测试用例 -&gt; 执行测试 -&gt; 提交测试发现的问题 -&gt; 所有问题已修复 -&gt; 结束</p>
<h4 id="测试过程划分"><a href="#测试过程划分" class="headerlink" title="测试过程划分"></a>测试过程划分</h4><p>策划（需求&amp;计划） -&gt; 设计 -&gt; 执行 -&gt; 评估 -&gt; 总结</p>
<ul>
<li>在逻辑上，测试活动是按顺序进行的</li>
<li>在实际测试过程中，这些活动是可以重叠或同时进行的</li>
</ul>
<h3 id="测试策划过程"><a href="#测试策划过程" class="headerlink" title="测试策划过程"></a>测试策划过程</h3><ul>
<li>进行测试需求的分析</li>
<li>确定需要测试的内容或质量特征</li>
<li>明确测试的充分性要求</li>
<li>提出测试的基本方法</li>
<li>确定测试的资源和技术需求</li>
<li>进行风险分析与评估</li>
<li>根据上述分析结果制定测试计划</li>
<li>根据测试计划开展相应的测试控制活动</li>
</ul>
<h3 id="需求测试"><a href="#需求测试" class="headerlink" title="需求测试"></a>需求测试</h3><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ul>
<li>过往的软件生命周期中，需求分析阶段是没有测试人员参与的</li>
<li>但随着软件过程的优化，测试人员的加入对需求分析阶段有了更大的作用</li>
<li>测试工程师参与需求分析，对需求了解很深刻，减少与开发人员的交互，节省时间</li>
<li>早期确定测试用例的编写思路，为测试打好了基础</li>
<li>可以获取一些测试数据，为测试用例设计提供帮助</li>
<li>可以发现需求不合理的地方，降低测试成本</li>
</ul>
<h4 id="需求测试的作用"><a href="#需求测试的作用" class="headerlink" title="需求测试的作用"></a>需求测试的作用</h4><ul>
<li><p>测试需求的分析用来确定整个测试工作，明确测试对象以及测试工作的范围和作用，并作为测试覆盖的基础</p>
</li>
<li><p>被确定的测试需求项必须是可核实的，测试需求必须有一个可观察、可评测的结果</p>
</li>
<li><p>如果无法核实的需求就不是测试需求</p>
</li>
<li><p>测试需求分析还包括与客户的交流以澄清某些混淆</p>
</li>
<li><p>明确哪些需求更重要</p>
</li>
<li><p>确保风险承担着尽早地对项目达成共识</p>
</li>
<li><p>并对将来的产品有个清晰的认识</p>
</li>
<li><p>测试需求是制定测试计划的基本依据</p>
</li>
<li><p>测试需求是设计测试用例的指导</p>
</li>
<li><p>确定了要测什么、测哪些方面才能有效设计用例</p>
</li>
</ul>
<h4 id="需求验证"><a href="#需求验证" class="headerlink" title="需求验证"></a>需求验证</h4><ul>
<li>审查需求文档<ul>
<li>对需求文档及相关模型进行仔细检查</li>
<li>另外在需求开发期间所作的非正式评审也是有所裨益的</li>
</ul>
</li>
<li>以需求为依据编写测试用例<ul>
<li>编写用户手册</li>
<li>在需求开发早期即可起草一份浅显易懂的用户手册，用以描述出所有对用户可见的功能并用它作为需求规格说明的参考并辅助需求分析</li>
</ul>
</li>
<li>确定合格的标准<ul>
<li>让用户描述什么样的产品才算满足他们的要求和适合他们的使用</li>
<li>将确认合格的测试建立在使用场景描述或使用实例的基础之上</li>
</ul>
</li>
</ul>
<h4 id="需求规格说明书检查列表"><a href="#需求规格说明书检查列表" class="headerlink" title="需求规格说明书检查列表"></a>需求规格说明书检查列表</h4><table>
<thead>
<tr>
<th>序号</th>
<th>检查项</th>
<th>检查结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>用户覆盖了用户提出的所有需求项</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>用词是否清晰，语义是否存在有歧义的地方</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>是否清楚地描述了软件需要做什么以及不做什么</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>是否描述了软件的目标环境</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>是否对需求项进行了合理的编号</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>需求项是否前后一致、彼此不冲突</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>是否清楚地说明了系统的每个输入、输出格式，以及输入与输出之间的对应关系</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>是否清晰地描述了软件系统的性能要求</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>需求的优先级是否合理分配</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>是否描述了各种约束条件</td>
<td>是【】 否【】 NA【】</td>
<td></td>
</tr>
</tbody></table>
<h3 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h3><h4 id="测试前的思考"><a href="#测试前的思考" class="headerlink" title="测试前的思考"></a>测试前的思考</h4><ul>
<li>你知道要测试的系统是干什么的吗？</li>
<li>你了解系统有哪些特点吗？</li>
<li>系统有些什么功能？</li>
<li>系统哪些部分需要测试？哪些不要测试？</li>
<li>系统对性能有什么要求？</li>
<li>系统对安全性有什么要求？</li>
<li>……</li>
</ul>
<h4 id="测试策略是什么"><a href="#测试策略是什么" class="headerlink" title="测试策略是什么"></a>测试策略是什么</h4><ul>
<li>测试策略是描述测试项目和测试任务之间的关系</li>
<li>它用来说明要测什么，如何测，如何协调测试资源和测试时间等</li>
<li>测试策略制定得是否合理高效会对测试项的进度产生很大的影响</li>
</ul>
<h4 id="测试策略要素"><a href="#测试策略要素" class="headerlink" title="测试策略要素"></a>测试策略要素</h4><p>测试安排发布计划 -&gt; 测试范围 -&gt; 测试资源 -&gt; 测试环境 -&gt; 测试方法 -&gt; 用例设计方法 -&gt; 文档管理 -&gt; 风险管理 -&gt; 上线跟踪验证</p>
<ul>
<li>测试安排、发布计划<ul>
<li>罗列测试项目本身重要的里程碑</li>
<li>每个里程碑都需要有明确的结束时间</li>
<li>这个时间可以指导我们后续的测试</li>
<li>如果测试时间安排不足，我们就可以在后续的测试范围中挑选优先级比较高的特性来执行测试</li>
<li>这样可以最大程度的保证产品的质量</li>
</ul>
</li>
<li>测试范围（按优先级排列）<ul>
<li>分为In Scope和Out Of Scope</li>
<li>需要说明哪些模块是在测试范围中的，哪些是本阶段测试不考虑的</li>
<li>对于在测试范围中的模块，需要给出优先级</li>
<li>以便相应测试时间不足的情况</li>
<li>对于不在测试范围中的模块，需要给出原因</li>
<li>为什么在本测试阶段不考虑测</li>
</ul>
</li>
<li>测试资源<ul>
<li>测试资源在测试策略中也是很重要的一环，它分为人力和工具两部分</li>
<li>人力资源主要是参与测试的人员，当然可以包括很多的角色，如专业测试人员，客户，产品经理等</li>
<li>工具主要是指可能用到的其他软件</li>
</ul>
</li>
<li>测试环境<ul>
<li>测试环境主要包括推荐环境解决方案，操作系统要求，软硬件要求</li>
<li>对于推荐解决方案，需要陈述的是对测试项目、对其他软件的依赖</li>
<li>比如测试项目对Java有依赖，推荐版本可能就是1.7</li>
</ul>
</li>
<li>测试方法<ul>
<li>测试方法的罗列主要是为了说明针对测试项目我们要开展哪些类型的测试</li>
<li>功能测试是必须的，非功能测试是可选的</li>
</ul>
</li>
<li>文档管理<ul>
<li>对于一个完整的产品来说，文档是很重要的一环</li>
<li>它一般包括安装、升级文档，用户指南等</li>
<li>文档不单单是一个文件</li>
<li>它需要经过完整的测试才能发布给用户</li>
<li>差的文档很可能会误导用户，从而使他们对测试项目失去信心</li>
</ul>
</li>
<li>风险管理<ul>
<li>风险管理模块需要罗列出来现在已知的可能会出现不确定性的因素</li>
<li>这些因素可能来自技术，资源或者其他方面的</li>
</ul>
</li>
</ul>
<h3 id="测试计划与测试方案"><a href="#测试计划与测试方案" class="headerlink" title="测试计划与测试方案"></a>测试计划与测试方案</h3><ul>
<li><strong>测试策略</strong>：侧重需求分析，评估风险，定义测试范围<ul>
<li>确定测试方法，制定测试启动、停止、完成标准和条件</li>
</ul>
</li>
<li><strong>测试计划</strong>：制定项目测试过程中的测试重点<ul>
<li>各个阶段的任务分配以及时间进度安排</li>
<li>并提出对各项任务的评估，风险分析，可以包括测试策略</li>
</ul>
</li>
<li><strong>测试方案</strong>：侧重测试的方法，测试环境的规划<ul>
<li>测试工具的设计和选择，测试用例的设计方法，测试代码的设计方案</li>
</ul>
</li>
</ul>
<h4 id="测试策略-vs-测试计划-vs-测试方案"><a href="#测试策略-vs-测试计划-vs-测试方案" class="headerlink" title="测试策略 vs 测试计划 vs 测试方案"></a>测试策略 vs 测试计划 vs 测试方案</h4><ul>
<li>实际实施过程中；往往存在这样类似的方式</li>
<li>测试方案 &#x3D; 测试计划 + 用例设计方案 + 工具选择 + 自动化&#x2F;性能测试具体方案</li>
<li>测试计划 &#x3D; 测试策略 + 测试任务分配 + 时间进度安排</li>
</ul>
<h4 id="测试方案列表"><a href="#测试方案列表" class="headerlink" title="测试方案列表"></a>测试方案列表</h4><ul>
<li>1 需求说明<ul>
<li>1.1 需求汇总</li>
<li>1.2 需求变更</li>
</ul>
</li>
<li>2 总体计划安排和负责人<ul>
<li>2.1 测试计划进度表</li>
</ul>
</li>
<li>3 测试方案<ul>
<li>3.1 测试重点</li>
<li>3.2 联测方案</li>
<li>3.3 测试策略方法</li>
<li>3.4 测试工具平台</li>
</ul>
</li>
<li>4 环境搭建部署及数据准备<ul>
<li>4.1 环境拓扑</li>
<li>4.2 应用部署</li>
<li>4.3 数据准备</li>
</ul>
</li>
<li>5 测试执行计划<ul>
<li>5.1 测试计划</li>
<li>5.2 正向用例</li>
<li>5.3 反向用例</li>
<li>5.4 用例评审</li>
</ul>
</li>
<li>6 测试工单<ul>
<li>6.1 冒烟工单</li>
<li>6.2 单测工单</li>
<li>6.3 联测工单</li>
<li>6.4 预发布验证工单</li>
<li>6.5 灰度验证工单</li>
<li>6.6 线上验证工单</li>
</ul>
</li>
<li>7 测试限制及无法测试功能列表</li>
<li>8 测试情况日汇总&amp;风险点、待确认列表<ul>
<li>8.1 每日测试情况及风险点</li>
</ul>
</li>
</ul>
<h3 id="测试方案评审"><a href="#测试方案评审" class="headerlink" title="测试方案评审"></a>测试方案评审</h3><p>目前，开发有需求说明会、设计评审会、代码复审会等各种会议，但多是站在开发的角度，从需求和代码层面进行复审和风险规避，在测试环节和测试阶段缺少以测试为主体的评审机制和沟通机制</p>
<p>容易造成以下几方面问题：</p>
<ul>
<li><p>仅从文档、沟通获取信息，可能会造成信息不对称，认识片面，理解错误或不深入等问题</p>
</li>
<li><p>缺少同行交叉评审和开发评审机制，无法充分发挥集体智慧，个人的思维难以突破，可能会出现测试遗漏的情况</p>
</li>
<li><p>评审目的</p>
<ul>
<li>呈现测试的工作</li>
<li>与开发达成共识</li>
<li>不同的思维方式碰撞出火花，借鉴别人的思考方式</li>
<li>培养这样的行为模式：愿意为团队或他人出谋划策</li>
<li>发挥团队协作，最大限度发挥个人的经验，特长，实现技能互补</li>
</ul>
</li>
<li><p>评审重点</p>
<ul>
<li>采用的测试方法</li>
<li>等价类划分的依据</li>
<li>测试数据的选取和准备方法</li>
<li>流程测试的路径组合</li>
<li>数据比对选取的对象和数据检查点</li>
<li>是否需要模拟数据及模拟数据的方法</li>
<li>基于风险的测试取舍</li>
</ul>
</li>
</ul>
<h2 id="软件测试设计"><a href="#软件测试设计" class="headerlink" title="软件测试设计"></a>软件测试设计</h2><h3 id="测试设计"><a href="#测试设计" class="headerlink" title="测试设计"></a>测试设计</h3><p>测试设计是将概括的测试目标转化为具体的测试条件和测试用例的一系列活动</p>
<h4 id="测试分析和设计的主要任务"><a href="#测试分析和设计的主要任务" class="headerlink" title="测试分析和设计的主要任务"></a>测试分析和设计的主要任务</h4><ul>
<li>评审测试依据（需求，系统架构、设计和接口说明）</li>
<li>评估设计依据和测试对象的可靠性</li>
<li>通过对测试项、规格说明、测试对象行为和结构的分析，识别测试条件并确定优先级</li>
<li>设计测试用例，并确定优先级</li>
<li>确定测试条件和测试用例所需的必要的测试数据</li>
</ul>
<h4 id="确定测试条件"><a href="#确定测试条件" class="headerlink" title="确定测试条件"></a>确定测试条件</h4><ul>
<li>依据在测试策略或测试计划中确定的测试技术</li>
<li>通过对测试依据和测试目标的分析，可以确定需要测试的内容，获得测试条件</li>
</ul>
<h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><ul>
<li>测试用例是通过使用在测试计划中确定的测试技术，对于已确定的测试条件进行逐步推敲，精炼而设计出来的重点说明如何具体操作产生何种结果的文档</li>
<li>测试用例应该具有可重复性、可验证性和需求可追踪性</li>
</ul>
<h4 id="测试用例设计包括以下关键点"><a href="#测试用例设计包括以下关键点" class="headerlink" title="测试用例设计包括以下关键点"></a>测试用例设计包括以下关键点</h4><ul>
<li>前提条件，如项目或局部测试环境的需求，及其交付计划</li>
<li>测试步骤</li>
<li>测试数据</li>
<li>预期结果</li>
</ul>
<h4 id="测试用例案例"><a href="#测试用例案例" class="headerlink" title="测试用例案例"></a>测试用例案例</h4><table>
<thead>
<tr>
<th>序号</th>
<th>模块名称</th>
<th>测试子项</th>
<th>用例名称（测试意图）</th>
<th>用例级别</th>
<th>预置条件</th>
<th>测试步骤</th>
<th>预期结果</th>
<th>测试结果</th>
<th>缺陷编号</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="测试用例常用设计方法"><a href="#测试用例常用设计方法" class="headerlink" title="测试用例常用设计方法"></a>测试用例常用设计方法</h4><ul>
<li>等价类划分法</li>
<li>边界值法</li>
<li>因果图设计法</li>
<li>判定表设计法</li>
<li>正交实验法</li>
</ul>
<h3 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h3><p>等价类划分的办法是把程序的输入域划分为若干部分，然后从每个部分中选取少数代表性数据当作测试用例，每一类的代表性数据在测试中的作用等价于这一类中的其他值，也就是说，如果某一类中的一个例子发现了错误，这一等价类的其他例子也能发现同样的错误。反之，如果某一类中的一个例子没有发现错误，则这一类中的其他例子也不会查出错误。</p>
<h4 id="等价类划分方法"><a href="#等价类划分方法" class="headerlink" title="等价类划分方法"></a>等价类划分方法</h4><ul>
<li>如果输入条件规定了取值的范围或值的个数，则可以确定一个有效等价类和两个无效等价类</li>
<li>如果一个输入条件说明了一个“必须成立”的情况，则可划分一个有效等价类和一个无效等价类</li>
<li>如果输入条件规定了输入数据的一组可能的值，而且程序是用不同的方式处理每一种值，则可为每一种值划分一个有效等价类，并划分一个无效等价类</li>
<li>如果我们确知，已划分的某等价类中的各元素（例子）在程序中的处理方式是不同的，则应据此将此等价类进一步划分成更小的等价类</li>
<li>在确定了等价类之后，建立等价类表，列出所有划分出的等价类</li>
</ul>
<h4 id="基于等价类划分的用例设计"><a href="#基于等价类划分的用例设计" class="headerlink" title="基于等价类划分的用例设计"></a>基于等价类划分的用例设计</h4><ul>
<li>明确测试对象，非测试对象保证正确</li>
<li>为每个等价类规定一个唯一的编号</li>
<li>设计一个新的测试用例，使其尽可能多地覆盖尚未覆盖的有效等价类。重复这一步，最后使得所有有效等价类均被测试用例所覆盖</li>
<li>设计一个新的测试用例，使其只覆盖一个无效等价类。重复这一步使所有无效等价类被覆盖</li>
</ul>
<h3 id="等价类划分实战"><a href="#等价类划分实战" class="headerlink" title="等价类划分实战"></a>等价类划分实战</h3><ul>
<li>STEP1：根据测试需求可以分为三个等价类：<ul>
<li>一个有效数据的等价类，两个无效数据等价类</li>
<li>有效数据等价类就是：由那些对程序的规格说明有意义的、合理的输入数据所构成的集合</li>
<li>无效数据等价类就是：那些对程序的规格说明不合理的或无意义的输入数据所构成的集合</li>
</ul>
</li>
<li>STEP2：建立等价类表<ul>
<li>在实际工作中，我们通常在确立了等价类以后，把程序中所有等价类建立等价类表，以便在编写测试用例的时候有所依据</li>
</ul>
</li>
<li>STEP3：确定测试用例<ul>
<li>为等价类表中的每一个等价类分配一个唯一的编号</li>
<li>设计一个新的测试用例，使它能够尽量覆盖尚未覆盖的有效等价类</li>
<li>重复这一步骤，从而使所有有效等价类均被测试用例所覆盖</li>
<li>与上步类似，设计一个新的测试用例，使它只覆盖一个无效等价类</li>
<li>重复这一步骤，从而使所有无效等价类均被测试用例所覆盖</li>
</ul>
</li>
<li>STEP4：细化等价类划分</li>
<li>STEP5：完善测试用例</li>
</ul>
<h4 id="等价类的特点"><a href="#等价类的特点" class="headerlink" title="等价类的特点"></a>等价类的特点</h4><ul>
<li>测试相同的内容</li>
<li>如果等价类中的一个测试能够捕获一个缺陷，那么选择该等价类中的其他测试也能捕获该缺陷</li>
<li>如果等价类中的一个测试不能捕获缺陷，那么选择该等价类中的其他测试也不会捕获缺陷</li>
<li>如果正确地划分等价类，可以大大降低测试用例的数量，测试会准确有效</li>
<li>如果错误的将两个不同的等价类当作一个等价类，那么就会遗漏一种测试情况</li>
<li>相反的，把同一个等价类看作了两个不同的等价类，那么测试就会是冗余的</li>
</ul>
<h4 id="等价类划分要注意的问题"><a href="#等价类划分要注意的问题" class="headerlink" title="等价类划分要注意的问题"></a>等价类划分要注意的问题</h4><ul>
<li>不但要考虑有效等价类，也要考虑无效等价类</li>
<li>仔细划分，审查划分</li>
<li>过于粗略可能会漏掉软件缺陷</li>
<li>组织评审</li>
</ul>
<h3 id="边界值法"><a href="#边界值法" class="headerlink" title="边界值法"></a>边界值法</h3><h4 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h4><ul>
<li>边界值分析法是一种补充等价划分的测试用例设计技术，它不是选择等价类的任意元素，二是选择等价类边界的测试用例</li>
<li>实践证明，在设计测试用例时，对边界附近的处理必须给予足够的重视，为检验边界附近的处理专门设计测试用例，常常取得良好的测试效果</li>
<li>边界值分析法不仅重视输入条件边界，而且也从输出域导出测试用例</li>
</ul>
<h4 id="边界值设计的原则"><a href="#边界值设计的原则" class="headerlink" title="边界值设计的原则"></a>边界值设计的原则</h4><p>如果输入条件规定了取值范围，应以该范围的边界内及刚刚超过范围的边界外的值作为测试用例</p>
<p>如以a和b作为边界，测试用例应当包含a和b及略大于a和略小于b的值</p>
<h3 id="因果图-amp-判定表"><a href="#因果图-amp-判定表" class="headerlink" title="因果图&amp;判定表"></a>因果图&amp;判定表</h3><h4 id="因果图法"><a href="#因果图法" class="headerlink" title="因果图法"></a>因果图法</h4><p>等价类划分法和边界值分析方法都是着重考虑输入条件，而不考虑输入条件的各种组合、输入条件之间的相互制约关系，如果在测试时必须考虑输入条件的各种组合，则可能的组合数字将是天文数字，因此必须考虑采用一种适用于描述多种条件的组合、产生多个相应动作的测试方法，这就需要利用因果图（逻辑模型）</p>
<h4 id="因果图-判定表"><a href="#因果图-判定表" class="headerlink" title="因果图-判定表"></a>因果图-判定表</h4><p>因果图法基于这样的思想：一些程序的功能可以用决策表的形式来表示，并根据输入条件的组合情况规定相应的操作</p>
<p>因此，可以考虑为决策表中的每一列设计一个测试用例，以便测试程序在输入条件的某个组合下的输出是否正确</p>
<p>概括地说，因果图方法就是从程序规格说明书的描述中找出因（输入条件）和果（输出结果或程序状态的改变）</p>
<p>将因果图转化为判定表，为决策表中的每一列设计一个测试用例</p>
<p>这种方法考虑到了输入情况的各种组合以及各个输入情况之间的相互制约关系</p>
<h4 id="判定表"><a href="#判定表" class="headerlink" title="判定表"></a>判定表</h4><p>判定表（Decision Table）是分析和表达多逻辑条件下执行不同操作的工具</p>
<p>在程序设计发展的初期，判定表就已被当作编写程序的辅助工具了</p>
<p>因为它可以把复杂的逻辑关系和多种条件组合的情况表达得即具体又明确</p>
<p>判定表通常由四个部分组成：</p>
<ul>
<li>条件桩（Condition Stub）：列出了问题得所有条件，通常认为列出的条件的次序无关紧要</li>
<li>动作桩（Action Stub）：列出了问题规定可能采取的操作，这些操作的排列顺序没有约束</li>
<li>条件项（Condition Entry）：列出针对它左列条件的取值，在所有可能情况下的真假值</li>
<li>动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作</li>
</ul>
<h3 id="设计步骤（因果图-amp-判定表）"><a href="#设计步骤（因果图-amp-判定表）" class="headerlink" title="设计步骤（因果图&amp;判定表）"></a>设计步骤（因果图&amp;判定表）</h3><ol>
<li>分析软件规格说明中哪些是原因（即输入条件或输入条件的等价类），哪些是结果（即输出条件），并给每个原因和结果赋予一个标识符</li>
<li>分析软件规格说明中语义的内容，找出原因和结果之间、原因和原因之间对应的关系，根据这些关系画出因果图</li>
<li>由于语法或环境的限制，有些原因和原因之间、原因和结果之间的组合情况不可能出现。为表明这些特定的情况，在因果图上使用一些记号表明约束或限制条件</li>
<li>把因果图转换为判定表</li>
<li>根据判定表中的每一列设计测试用例</li>
</ol>
<h3 id="正交实验法"><a href="#正交实验法" class="headerlink" title="正交实验法"></a>正交实验法</h3><p>正交试验设计法（Orthogonal experimental design），是从大量的试验点中挑选出适量的、有代表性的点，，应用依据伽罗卡瓦理论导出的“正交表”，合理地安排实验的一种科学的试验设计方法</p>
<ul>
<li>指标：通常把判断试验结果优劣的标准叫做试验的指标</li>
<li>因子（因素Factor）：所有影响试验指标的条件</li>
<li>因子的状态（水平Level）：而影响实验因子的，叫做因子的状态（因子变量的取值）</li>
</ul>
<h4 id="正交实验法设计步骤"><a href="#正交实验法设计步骤" class="headerlink" title="正交实验法设计步骤"></a>正交实验法设计步骤</h4><ol>
<li>提取功能说明，构造因子–状态表<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">因子1</th>
<th align="center">因子2</th>
<th align="center">…</th>
<th align="center">因子n</th>
</tr>
</thead>
<tbody><tr>
<td align="center">状态1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">状态2</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">…</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">状态m</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li>加权筛选，生成因素分析表<br>计算各因子和状态的权值，删去一部分权值较小，即重要性较小的因子或状态，使最后生成的测试用例集缩减到允许范围</li>
<li>利用正交表构造测试数据集<ul>
<li>如果各个因子的状态树是不统一的，几乎不可能出现均匀的情况，必须首先用逻辑命令来组合各因子的状态，作出布尔图</li>
<li>根据布尔图得到相应结束的正交表</li>
<li>依照因果图上根节点到叶子节点的顺序逐步替换正交表上的中间节点，得到最终的正交表</li>
</ul>
</li>
<li>利用正交表每行数据构造测试用例<ul>
<li>正交表<br>正交表的表现形式：Ln(t^c)<br>其中：L为正交表的代号，n为行数（试验次数），t为水平数，c为列数（因素数）</li>
<li>例如：L4(2^3)<br>它表示需做4次实验，最多可观察3个因素，每个因素均为2水平</li>
</ul>
</li>
<li>一个正交表也可以各列的水平数不相等，我们称它为混合型正交表，如L8(2^4 4^1)<br>此表的5列中，有1列为4水平，4列为2水平</li>
</ol>
<h4 id="如何查找正交表"><a href="#如何查找正交表" class="headerlink" title="如何查找正交表"></a>如何查找正交表</h4><ol>
<li><a target="_blank" rel="noopener" href="http://support.sas.com/techsup/technote/ts723_Designs.txt">Technical Support(support.sas.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.york.ac.uk/depts/maths/tables/orthogonal.htm">Dr.GenichiTaguchi设计的正交表</a></li>
</ol>
<h3 id="测试场景设计"><a href="#测试场景设计" class="headerlink" title="测试场景设计"></a>测试场景设计</h3><ul>
<li>现在的软件几乎都是用事件触发来控制流程的。事件触发时的情景形成了场景，而同一事件不同的触发顺序和处理结果就形成了事件流</li>
<li>这种在软件设计方面的思想可以引入到软件测试中，可以生动地描绘出事件触发时的情景，有利于设计测试用例，同时使测试用例更容易理解和执行</li>
</ul>
<h4 id="场景法基础设计"><a href="#场景法基础设计" class="headerlink" title="场景法基础设计"></a>场景法基础设计</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/157e96bd89a8454995bcfeb663d8f35a.png" alt="场景法基础设计"></p>
<ul>
<li><p>经过用例的每条路径都用基本流和备选流来表示，直黑线表示基本流，是经过用例的最简单的路径</p>
</li>
<li><p>备选流用不同的色彩表示，一个备选流可能从基本流开始，在某个特定条件下执行，然后重新加入基本流中（如备选流1和3）</p>
</li>
<li><p>也可能起源于另一个备选流（如备选流2），或者终止用例而不再重新加入某个流（如备选流2和4）</p>
</li>
<li><p>每个经过用例的可能路径，可以确定不同的用例场景</p>
</li>
<li><p>从基本流开始，再将基本流和备选流结合起来，可以确定以下用例场景：</p>
<ul>
<li>场景1 基本流</li>
<li>场景2 基本流 备选流1</li>
<li>场景3 基本流 备选流1 备选流2</li>
<li>场景4 基本流 备选流3</li>
<li>场景5 基本流 备选流3 备选流1</li>
<li>场景6 基本流 备选流3 备选流1 备选流2</li>
<li>场景7 基本流 备选流4</li>
<li>场景8 基本流 备选流3 备选流4</li>
</ul>
</li>
<li><p>根据说明，描述出程序的基本流和各项备选流</p>
</li>
<li><p>根据基本流和各项备选流生成不同的场景</p>
</li>
<li><p>对每一个场景生成相应的测试用例</p>
</li>
<li><p>对生成的所有测试用例重新复审，去掉多余的测试用例，测试用例确定后，对每一个测试用例确定测试数据值</p>
</li>
</ul>
<h3 id="用例设计的综合运用"><a href="#用例设计的综合运用" class="headerlink" title="用例设计的综合运用"></a>用例设计的综合运用</h3><ol>
<li>测试用例项划分<br>测试用例划分的经典方法是瀑布模型（不是软件开发模型的瀑布模型），从上到下，逐渐细分，大模块包括小模块，小模块包括更小的模块<br>要从更多的角度切入系统，把系统切分成一块一块的，来进行测试，从而保证测试大项的完整性</li>
<li>切面设计<ul>
<li>功能点切面：最常见的切面，通常认为页面上的一个按钮就是一个功能点。根据功能的复杂程度，按每个功能进行用例的撰写</li>
<li>隐含切面：完整业务流程的测试；从需求、业务角度进行编写</li>
</ul>
</li>
<li>功能点用例设计<ul>
<li>任何情况下都必须使用边界值分析方法，经验表明用这种方法设计出测试用例发现程序错误的能力最强</li>
<li>必要时用等价类划分方法补充一些测试用例</li>
<li>如果程序的功能说明中含有输入条件的组合情况，则一开始就可选用因果图法</li>
<li>如果程序业务复杂度比较高，则适当使用场景法补充一部分测试用例</li>
</ul>
</li>
</ol>
<h2 id="测试执行管理"><a href="#测试执行管理" class="headerlink" title="测试执行管理"></a>测试执行管理</h2><h3 id="测试执行过程"><a href="#测试执行过程" class="headerlink" title="测试执行过程"></a>测试执行过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[项目提测] --&gt; B[冒烟测试]</span><br><span class="line">B --&gt; |通过| C[系统测试] --&gt; D[用例执行]</span><br><span class="line">B --&gt; |未通过| A</span><br><span class="line">D --&gt; |通过| E[测试通过]</span><br><span class="line">D --&gt; |失败| F[提出缺陷] --&gt; G[研发修改] --&gt; D</span><br></pre></td></tr></table></figure>

<h3 id="测试执行阶段的主要任务"><a href="#测试执行阶段的主要任务" class="headerlink" title="测试执行阶段的主要任务"></a>测试执行阶段的主要任务</h3><ul>
<li>确定测试用例的优先级</li>
<li>开发测试规程并确定优先级，创建测试数据，同时也可以准备测试用具和设计自动化测试脚本</li>
<li>根据测试规程创建测试套件，以提高测试执行的效率</li>
<li>确认已经正确搭建了测试环境</li>
<li>根据计划的执行顺序，通过手工或使用测试工具来执行测试规程</li>
<li>记录测试执行的结果，以及被测软件、测试工具和测试件的标识和版本</li>
<li>将实际结果和预期结果进行比较</li>
<li>对实际结果和预期结果之间的差异，作为事件上报，并且进行分析以确定引起差异的原因</li>
<li>缺陷修正后，重新进行测试活动</li>
</ul>
<h3 id="测试准入准出"><a href="#测试准入准出" class="headerlink" title="测试准入准出"></a>测试准入准出</h3><h4 id="测试准入标准"><a href="#测试准入标准" class="headerlink" title="测试准入标准"></a>测试准入标准</h4><ul>
<li>开发编码结束，并在开发环境已完成单元测试</li>
<li>需求上规定的功能均已实现；如没有完全实现，请提供测试范围</li>
<li>已完成集成测试，被测系统的基本流程可以走通，界面上的功能均实现，经过代码评审并符合软件编码规范</li>
<li>开发提交最新版本代码，以此为基线，提交并通知测试组进行测试</li>
<li>兼容性测试要求明确</li>
<li>安全测试和性能测试范围和要求</li>
</ul>
<h4 id="测试暂停、停止"><a href="#测试暂停、停止" class="headerlink" title="测试暂停、停止"></a>测试暂停、停止</h4><ul>
<li>测试人员先进行冒烟测试，若发现重大缺陷或bug过多时、或者流程卡壳导致基本流程无法走通，测试无法正常进行，可以暂停测试并返回开发</li>
<li>被测项目需调整而暂停的，测试也相应暂停</li>
<li>存在其他优先级更高的任务时，可以向领导申请暂停测试</li>
<li>被测系统经过系统测试，达到系统准出标准，可以停止测试</li>
</ul>
<h4 id="测试准出标准"><a href="#测试准出标准" class="headerlink" title="测试准出标准"></a>测试准出标准</h4><table>
<thead>
<tr>
<th align="center">序号</th>
<th>准出标准</th>
<th align="center">是</th>
<th align="center">否</th>
<th align="center">日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>被测项目满足需求原型的要求？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td>所有测试用例都已经通过评审？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td>所有测试用例都已成功执行？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td>测试覆盖率是否达到100%？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td>所有发现的缺陷都记录在缺陷管理系统？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6</td>
<td>一二级错误修复率达到100%？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">7</td>
<td>三四级错误修复率达到95%？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8</td>
<td>所有遗留问题都已有解决方案？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td>性能指标是否达到要求？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">10</td>
<td>兼容性测试（IE8，Chrome，火狐）是否满足？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">11</td>
<td>安全性测试是否达到要求？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">12</td>
<td>产出系统测试总结报告？</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="缺陷管理"><a href="#缺陷管理" class="headerlink" title="缺陷管理"></a>缺陷管理</h3><h4 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h4><ul>
<li>缺陷是一种泛称，它可以指功能的错误，也可以指性能低下，易用性差等</li>
<li>并不是所有测试人员都能提交被开发认可的缺陷，也不是测试员在任何时候都能提交被开发认可的缺陷</li>
</ul>
<h4 id="什么是软件缺陷"><a href="#什么是软件缺陷" class="headerlink" title="什么是软件缺陷"></a>什么是软件缺陷</h4><ol>
<li>软件未达到产品说明标明的功能</li>
<li>软件出现了产品说明书指明不会出现的错误</li>
<li>软件功能超出产品说明出指明范围</li>
<li>软件未达到产品说明书虽未指出但应达到的目标</li>
<li>软件测试员认为软件难以理解、不易使用、运行速度缓慢，或者最终用户认为不好</li>
</ol>
<h4 id="缺陷产生的原因"><a href="#缺陷产生的原因" class="headerlink" title="缺陷产生的原因"></a>缺陷产生的原因</h4><ul>
<li>工期短，任务大</li>
<li>程序设计错误</li>
<li>文档不完善</li>
<li>沟通交流不够</li>
<li>软硬件支持不完善</li>
<li>软件的复杂性</li>
<li>需求不断变化</li>
</ul>
<h4 id="发现缺陷"><a href="#发现缺陷" class="headerlink" title="发现缺陷"></a>发现缺陷</h4><ol>
<li>用户体验不够好</li>
<li>界面上有明显的错误信息</li>
<li>功能不完备，没有按照需求说明编写代码，致使某些功能缺失</li>
<li>功能不完善，不能正常运行或者运行的过程中出现程序崩溃、停止运行的情况</li>
<li>逻辑不正确，与需求说明书、测试用例不符</li>
<li>模块之间的交互性不好，与其他的模块做集成测试时遇到问题</li>
<li>程序的性能不够好，不能承载压力考验</li>
</ol>
<h3 id="缺陷报告–注意事项"><a href="#缺陷报告–注意事项" class="headerlink" title="缺陷报告–注意事项"></a>缺陷报告–注意事项</h3><h4 id="BUG重现"><a href="#BUG重现" class="headerlink" title="BUG重现"></a>BUG重现</h4><ol>
<li>不要想当然地接受任何假设，要做好记录</li>
<li>查找时间依赖和竞争条件的问题</li>
<li>边界条件软件缺陷、内存缺陷和数据溢出等白盒问题可能会慢慢自己显露出来</li>
<li>状态缺陷仅在特定软件状态中显露出来</li>
<li>考虑资源依赖性和内存、网络、硬件共享的相互作用</li>
</ol>
<h4 id="无法重现的BUG"><a href="#无法重现的BUG" class="headerlink" title="无法重现的BUG"></a>无法重现的BUG</h4><ul>
<li>首先，应当对这样的缺陷进行详细的记录，并尽快提交给开发人员</li>
<li>其次，对于寻找难以再现的缺陷要合理地安排时间，要考虑到测试项目的整体进度，对一时难以再现的缺陷可以暂时搁置，以保证项目的正常进度</li>
<li>最后在测试过程中对未再现缺陷予以关注</li>
</ul>
<h4 id="缺陷报告"><a href="#缺陷报告" class="headerlink" title="缺陷报告"></a>缺陷报告</h4><ul>
<li>缺陷报告是对缺陷进行记录、分类和跟踪的文档</li>
<li>软件测试人员的任务之一就是书写良好的软件缺陷报告</li>
<li>提供准确、完整、简洁、一致的缺陷报告是体现软件测试的专业性、高质量的主要评价指标</li>
<li>通常，缺陷报告的直接读者是软件开发人员和质量管理人员，除此之外，来自市场和技术支持等部门的人也可能需要查看缺陷情况</li>
</ul>
<h4 id="缺陷报告包含信息"><a href="#缺陷报告包含信息" class="headerlink" title="缺陷报告包含信息"></a>缺陷报告包含信息</h4><ul>
<li>易于搜索软件测试报告的缺陷</li>
<li>报告的软件缺陷进行了必要的隔离，报告的缺陷信息具体、准确</li>
<li>软件开发人员希望获得缺陷的本质特征和复现步骤</li>
<li>市场和技术支持等部门希望获得缺陷类型分布以及对市场和用户的影响程度</li>
</ul>
<h4 id="缺陷报告的写作准则（5C）"><a href="#缺陷报告的写作准则（5C）" class="headerlink" title="缺陷报告的写作准则（5C）"></a>缺陷报告的写作准则（5C）</h4><ul>
<li>Correct（准确）：每个组成部分的描述准确，不会引起误解</li>
<li>Clear（清晰）：每个组成部分的描述清晰，易于理解</li>
<li>Concise（简洁）：只包含必不可少的信息，不包括任何多余的内容</li>
<li>Complete（完整）：包含复现该缺陷的完整步骤和其他本质信息</li>
<li>Consistent（一致）：按照一致的格式书写全部缺陷报告</li>
</ul>
<h4 id="缺陷报告的组织架构"><a href="#缺陷报告的组织架构" class="headerlink" title="缺陷报告的组织架构"></a>缺陷报告的组织架构</h4><ol>
<li>缺陷的标题</li>
<li>缺陷的基本信息</li>
<li>测试的软件和硬件环境</li>
<li>测试的软件版本</li>
<li>缺陷的类型</li>
<li>缺陷的严重程度</li>
<li>缺陷的处理优先级</li>
<li>复现缺陷的操作步骤</li>
<li>缺陷的实际结果描述</li>
<li>期望的正确结果描述</li>
<li>注释文字和截取的缺陷图像</li>
</ol>
<h4 id="缺陷标题"><a href="#缺陷标题" class="headerlink" title="缺陷标题"></a>缺陷标题</h4><ul>
<li>尽量按缺陷发生的原因与结果的方式书写（“执行完A后，发生B” 或者 “发生B，当A执行后”）</li>
<li>避免使用模糊不清的词语，例如“功能中断”，“功能不正确”，“行为不起作用”等。应该使用具体文字说明功能如何中断，如何不正确，或如何不起作用</li>
<li>为了方便搜索和查询，请使用关键字</li>
<li>为了便于他人理解，避免使用术语、俚语或过分具体的测试细节</li>
</ul>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><table>
<thead>
<tr>
<th>原始描述</th>
<th>错误原因</th>
<th>改进的标题</th>
</tr>
</thead>
<tbody><tr>
<td>英文单词的连字符不管用</td>
<td>描述太笼统。什么时候不起作用？</td>
<td>在行末尾换行时，不能根据英文单词长度设置连字符。</td>
</tr>
<tr>
<td>段落调整出现错误状态</td>
<td>描述太笼统。不正确的行为是什么？</td>
<td>选定两个单词，启动单词“字间距”自动调整后间隔排版错误</td>
</tr>
<tr>
<td>警告：该命令产生了错误的结果。</td>
<td>没有包含原因与结果信息。描述内容太长。</td>
<td>更新头像图像保存到服务器时，警告：“错误”。</td>
</tr>
<tr>
<td>在鼠标点击执行每一个拷贝或复制的功能之后，响应事件很长。</td>
<td>没有指明原因和结果，包括了过分详细的细节信息</td>
<td>拷贝和复制功能执行效率低</td>
</tr>
<tr>
<td>插入的引号成为特殊符号</td>
<td>信号没有充分隔离。所有的引号都如此吗？什么类型的引号。</td>
<td>在文档中插入一个智能引号成为不可识别的字符串。</td>
</tr>
</tbody></table>
<h4 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h4><ul>
<li>复现步骤包括如何使别人能够很容易地复现该缺陷的完整步骤。为了达到这个要求，复现步骤的信息必须是完整的、准确的、简明的、可复现的</li>
<li>但是实际如阿健测试过程中，总是存在一些不良的缺陷报告，主要的问题在于多余步骤、可读性差、难以理解、缺失步骤等</li>
<li>提供测试的预备步骤和信息</li>
<li>简单地一步一步地引导复现该缺陷</li>
<li>每一个步骤尽量只记录一个操作</li>
<li>每一个步骤前使用数字对步骤编号</li>
<li>尽量使用短语和短句，避免复杂句型和句式</li>
<li>复现的步骤要完整，准确，简短</li>
<li>没有缺漏任何操作步骤</li>
<li>每个步骤都是准确无误的</li>
<li>没有任何多余的步骤</li>
<li>将常见步骤合并为较少步骤</li>
<li>只记录每个操作步骤是什么，不需要包括每个步骤的执行结果</li>
</ul>
<h4 id="缺陷报告注意事项"><a href="#缺陷报告注意事项" class="headerlink" title="缺陷报告注意事项"></a>缺陷报告注意事项</h4><ul>
<li>缺陷报告已经向读者包含完整、准确、必要的信息了吗？</li>
<li>一个缺陷报告中是否只报告了一种缺陷？</li>
<li>读者是否能容易的搜索该缺陷？</li>
<li>步骤是否可以完全复现而且表达清楚吗？</li>
<li>是否包含了复现该缺陷需要的环境变量或测试所用的数据文件？</li>
<li>缺陷的标题是按照原因与结果的方式书写的吗？</li>
<li>实际结果和期望结果是否描述不够清楚而容易引起歧义吗？</li>
</ul>
<h3 id="缺陷报告的原则"><a href="#缺陷报告的原则" class="headerlink" title="缺陷报告的原则"></a>缺陷报告的原则</h3><ul>
<li>组织Structure: 测试人员应该采用深思熟虑的，小心谨慎的方法执行测试，并且做详尽的记录。这样可以促使他们对待测试有很好的认识。当错误发生的时候，一个有组织的测试人员能够指导最早出现问题的地方。</li>
<li>重现Reproduce: 测试人员在编写缺陷报告之前必须在检查问题是否可重现。如果错误不可再重现，仍然应该写下来，但是必须说明问题的偶然性。一个好的处理原则就是在编写缺陷报告之前必须反复尝试3次。</li>
<li>隔离Isolate: 在尝试编写缺陷报告之前，必须试着隔离错误。可以采用改变一些变量的方法，如系统的配置，它可能可以改变错误的症状。这些信息可以为开发人员着手调试提供思路。</li>
<li>归纳Generalize: 发现了一个已隔离的，可重现的问题后，应该对问题进行归纳。同一个问题是否出现在其他的模块或其他的地方？同一个故障是否有更加严重的问题？</li>
<li>对比Compare: 如果测试人员以前曾经验证过现在出错的测试用例，那么他就应该检查以前的测试结果以检查相同的条件以前的测试是否通过。如果是的话，那么这个问题就像是一个回归的错误。注意由于同一测试条件有可能出现在多个测试用例中，这个步骤就不仅仅只是检查一个测试用例在以前的多个结果。</li>
<li>总结Summarize: 在缺陷报告的第一行协商错误的总结是非常关键的。测试人员要花些时间思考已发现的错误对客户有何影响。这不仅仅要求测试人员编写的报告要能够吸引读者，使和管理层的沟通清晰，还要能够帮助设置错误修复的优先级别。</li>
<li>精简Condense: 在缺陷报告的初稿完成后，测试人员应该反复阅读它，集中剔除那些没有关系的步骤或词语。隐含的或模糊的说明和那些由于对没有任何关系的细节或者那些在重现错误过程中不需要的步骤而消磨报告欢迎程度的无穷唠叨都不是缺陷报告的目标。</li>
<li>消除歧义Disambiguate: 测试人员在精简空话的同时或其之后随即应该再仔细检查报告是否会有产生误解的地方。测试人员应该尽量避免使用模糊的，会产生歧义的主观的词语。目标是使用能够表述事实，清楚的，不会产生争执的词语。</li>
<li>中立Neutralize: 作为坏消息的传递人，和善地提交信息是一个挑战。如同所有地错误总结一样，独立的缺陷报告在措辞方面应该保持公正。攻击开发人员，指责潜在的错误，企图诙谐或使用挖苦将引起开发人员的憎恶，并且使注意力从“提高产品质量“这个大的目标上转移开了。</li>
<li>检查Review: 一旦测试人员感觉缺陷报告是他能够编写地最好版本，他应该将报告再给一个或多个同行进行检查。在允许的时间内，测试小组应该尽可能提交最好的缺陷报告。</li>
</ul>
<h3 id="缺陷跟踪"><a href="#缺陷跟踪" class="headerlink" title="缺陷跟踪"></a>缺陷跟踪</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[提交缺陷] --&gt; B[指派缺陷] --&gt; C&#123;确认缺陷&#125;</span><br><span class="line">C --&gt; |是|D&#123;推迟处理&#125;</span><br><span class="line">C --&gt; |否|E&#123;回归缺陷&#125;</span><br><span class="line">D --&gt; |否|F[处理缺陷] --&gt; E</span><br><span class="line">D --&gt; |是|G[遗留缺陷] --&gt; |后续版本处理|F</span><br><span class="line">E --&gt; |通过|H[关闭缺陷]</span><br><span class="line">E --&gt; |未通过|I[重新打开] --&gt; C</span><br></pre></td></tr></table></figure>

<table>
  <tbody>
    <tr>
      <th>步骤</th>
      <th>人员</th>
      <th>任务</th>
      <th>缺陷状态</th>
    </tr>
    <tr>
      <td align="center">1</td>
      <td>测试人员</td>
      <td>提交缺陷</td>
      <td>New</td>
    </tr>
    <tr>
      <td align="center">2</td>
      <td>测试负责人</td>
      <td>分配缺陷</td>
      <td></td>
    </tr>
    <tr>
      <td align="center">3</td>
      <td>项目或开发负责人</td>
      <td>分配缺陷</td>
      <td></td>
    </tr>
    <tr>
      <td align="center" rowspan="4">4</td>
      <td rowspan="2">开发人员</td>
      <td>验证缺陷--是缺陷</td>
      <td>Open</td>
    </tr>
    <tr>
      <td>验证缺陷--不是缺陷</td>
      <td>Declined</td>
    </tr>
    <tr>
      <td rowspan="2">开发人员</td>
      <td>对Open的缺陷再次确认，若可复现，则修正并记录缺陷产生原因和修正方法</td>
      <td>Fixed</td>
    </tr>
    <tr>      
      <td>对Open的缺陷再次确认，若不可重现</td>
      <td>Need More Info</td>
    </tr>
    <tr>
      <td align="center">5</td>
      <td>测试人员</td>
      <td>对Declined的缺陷进行验证-不是缺陷</td>
      <td>Closed</td>
    </tr>
    <tr>
      <td align="center">6</td>
      <td>评审委员会（由开发经理-测试经理-项目经理-市场人员等组成）</td>
      <td>对延期解决和分歧缺陷进行评审、分析、讨论和仲裁</td>
      <td></td>
    </tr>
    <tr>
      <td align="center" rowspan="2">7</td>
      <td rowspan="2">测试人员</td>
      <td>对Fixed的缺陷在新软件版本Build验证缺陷是否修复，若已经修复</td>
      <td>Closed</td>
    </tr>
    <tr>
      <td>对Fixed的缺陷在新软件版本Build验证缺陷是否修复，若没有修复</td>
      <td>Open</td>
    </tr>
  </tbody>
</table>

<h4 id="缺陷跟踪管理系统"><a href="#缺陷跟踪管理系统" class="headerlink" title="缺陷跟踪管理系统"></a>缺陷跟踪管理系统</h4><p>早期的缺陷跟踪大都是以缺陷记录单的形式完成，现在还有很多项目还用此方法，但是随着用户对软件功能需求的不断增加，软件算法和复杂度都发生了很多变化，随之而来的是软件缺陷的增长，这给缺陷跟踪带来了很大挑战。于是，缺陷跟踪管理系统应运而生<br>在软件行业发展历程中，曾经或者正在被大量使用的缺陷管理系统包括JIRA, BUGZILLA, QC, 禅道等，而目前，除了部分大型IT公司拥有自研的缺陷跟踪管理系统外，很多公司应用禅道来进行缺陷跟踪甚至是项目管理</p>
<h3 id="禅道项目管理系统"><a href="#禅道项目管理系统" class="headerlink" title="禅道项目管理系统"></a>禅道项目管理系统</h3><p><a target="_blank" rel="noopener" href="https://www.zentao.net/">禅道</a>是一款基于Scrum思想并集产品管理、项目管理、测试管理于一体，同时还包含了事务管理、组织管理等诸多功能的项目管理软件</p>
<h4 id="用户角色"><a href="#用户角色" class="headerlink" title="用户角色"></a>用户角色</h4><ul>
<li>系统管理员(Admin): 系统管理员主要负责添加用户，分配权限</li>
<li>产品经理(Product Owner): 产品人员主要负责产品管理</li>
<li>项目经理(Project Manager): 通过项目，协调产品人员，开发人员，测试人员完成产品</li>
<li>开发人员(Developer): 开发人员负责产品的研发</li>
<li>测试人员(QA): 测试人员保证产品的质量</li>
</ul>
<h4 id="最简使用"><a href="#最简使用" class="headerlink" title="最简使用"></a>最简使用</h4><ul>
<li>只使用禅道来进行产品管理</li>
<li>使用禅道来进行项目任务管理</li>
<li>只使用禅道来做BUG管理</li>
<li>个人使用禅道来做事物跟踪管理</li>
</ul>
<h4 id="项目模式基本流程"><a href="#项目模式基本流程" class="headerlink" title="项目模式基本流程"></a>项目模式基本流程</h4><ol>
<li>产品经理创建产品</li>
<li>产品经理创建需求</li>
<li>项目经理创建项目</li>
<li>项目经理确定项目要做的需求</li>
<li>项目经理分解任务，指派到人</li>
<li>测试人员测试，提交bug</li>
</ol>
<h3 id="易用性测试"><a href="#易用性测试" class="headerlink" title="易用性测试"></a>易用性测试</h3><ul>
<li>易用性测试是指用户使用软件时是否感觉方便，比如是否最多点击鼠标三次就可以达到用户的目的</li>
<li>易用性和可用性存在一定的区别，可用性是指是否可以使用，而易用性是指是否方便使用</li>
</ul>
<h4 id="易用性测试内容"><a href="#易用性测试内容" class="headerlink" title="易用性测试内容"></a>易用性测试内容</h4><ul>
<li>易用性测试包括针对应用程序的测试，同时还包括对用户手册系统文档的测试。通常采用质量外部模型来评价易用性</li>
<li>包括如下方面的测试：<ol>
<li>易理解性</li>
<li>易学习性</li>
<li>易操作性</li>
<li>吸引性</li>
<li>依从性</li>
</ol>
</li>
<li>易用性测试方法<ul>
<li>导航测试<ul>
<li>通过考虑下列问题，可以决定一个应用系统是否易于导航：<ul>
<li>导航是否直观？</li>
<li>系统的主要部分是否可通过主页存取？</li>
<li>系统是否需要站点地图、搜索引擎或其他的导航帮助？</li>
</ul>
</li>
</ul>
</li>
<li>图形测试<ul>
<li>在应用系统中，适当的图片和动画既能起到广告宣传的作用，又能起到美化页面的功能</li>
<li>一个应用系统的图形可以包括图片、动画、边框、颜色、字体、背景、按钮等</li>
<li>要确定图形有明确的用途，图片或动画不要胡乱地堆在一起，以免浪费传输时间</li>
<li>应用系统的图片尺寸要尽量地小，并且要能清楚地说明某件事情，一般都链接到某个具体的页面</li>
<li>验证所有页面字体的风格是否一致</li>
<li>背景颜色应该与字体颜色和前景颜色相搭配</li>
<li>图片的大小和质量也是一个很重要的因素，一般采用JPG或GIF压缩</li>
</ul>
</li>
<li>内容测试<ul>
<li>内容测试用来检验应用系统提供信息的正确性、准确性和相关性</li>
</ul>
</li>
<li>整体界面测试<ul>
<li>整体界面是指整个应用系统的页面结构设计，是给用户的一个整体感</li>
<li>例如<ul>
<li>当用户浏览应用系统时是否感到舒适，是否凭直觉就知道要找的信息在什么地方？</li>
<li>整个应用系统的设计风格是否一致？</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="测试点总结"><a href="#测试点总结" class="headerlink" title="测试点总结"></a>测试点总结</h4><h5 id="控件类"><a href="#控件类" class="headerlink" title="控件类"></a>控件类</h5><table>
<thead>
<tr>
<th align="center">编号</th>
<th>测试内容</th>
<th>是否通过</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>按钮名称易懂，用词准确，与同一界面上的其他按钮易于区分</td>
<td></td>
</tr>
<tr>
<td align="center">2</td>
<td>常见按钮支持快捷方式</td>
<td></td>
</tr>
<tr>
<td align="center">3</td>
<td>相同或相近功能的按钮用Frame框起来，并有功能说明或标题</td>
<td></td>
</tr>
<tr>
<td align="center">4</td>
<td>完成同一功能或任务的元素集中放置</td>
<td></td>
</tr>
<tr>
<td align="center">5</td>
<td>应首先输入数据和重要信息的空间在Tab顺序中靠前，并放在窗口上较醒目的位置</td>
<td></td>
</tr>
<tr>
<td align="center">6</td>
<td>选项卡控件(Tab)支持在页面间的快捷切换，常用快捷键Ctrl+Tab</td>
<td></td>
</tr>
<tr>
<td align="center">7</td>
<td>默认按钮要支持“回车”即选操作</td>
<td></td>
</tr>
<tr>
<td align="center">8</td>
<td>选择常用功能或数值作为默认值</td>
<td></td>
</tr>
<tr>
<td align="center">9</td>
<td>复选框、单选框、列表框、下拉列表框的内容或条目多的时候按选择概率的高低或字母顺序排序</td>
<td></td>
</tr>
<tr>
<td align="center">10</td>
<td>复选框或单选框有默认选项</td>
<td></td>
</tr>
<tr>
<td align="center">11</td>
<td>界面控件较小时使用下拉列表框而不用单选框</td>
<td></td>
</tr>
<tr>
<td align="center">12</td>
<td>选项条目较少时使用单选框，相反使用下拉列表框</td>
<td></td>
</tr>
<tr>
<td align="center">13</td>
<td>专业性强的软件要使用相关的专业术语，通用性界面则提倡使用通用性术语</td>
<td></td>
</tr>
<tr>
<td align="center">14</td>
<td>不同界面的通用按钮位置保持一致</td>
<td></td>
</tr>
<tr>
<td align="center">15</td>
<td>常用按钮的等价按钮保持一致</td>
<td></td>
</tr>
<tr>
<td align="center">16</td>
<td>对可能给用户带来损失的操作最好支持可逆性处理</td>
<td></td>
</tr>
<tr>
<td align="center">17</td>
<td>对可能造成等待时间较长的操作应该提供取消功能，并显示操作的状态</td>
<td></td>
</tr>
<tr>
<td align="center">18</td>
<td>根据需要，程序自动过滤输入的空格</td>
<td></td>
</tr>
</tbody></table>
<h5 id="菜单测试"><a href="#菜单测试" class="headerlink" title="菜单测试"></a>菜单测试</h5><table>
<thead>
<tr>
<th align="center">编号</th>
<th>测试内容</th>
<th>是否通过</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>常用菜单项要有快捷键</td>
<td></td>
</tr>
<tr>
<td align="center">2</td>
<td>菜单项前的图标能直观地代表要完成的操作</td>
<td></td>
</tr>
<tr>
<td align="center">3</td>
<td>一组菜单的使用有先后要求或有向导作用时，按先后次序排列</td>
<td></td>
</tr>
<tr>
<td align="center">4</td>
<td>没有顺序要求的菜单按使用频率和重要性排列，常用的和重要的放前面</td>
<td></td>
</tr>
<tr>
<td align="center">5</td>
<td>主菜单的宽度要接近，字数不多于四个，每个菜单项的字数最好能相同</td>
<td></td>
</tr>
<tr>
<td align="center">6</td>
<td>工具栏的图标可以根据用户的需求进行定制</td>
<td></td>
</tr>
<tr>
<td align="center">7</td>
<td>相同或相近功能的工具栏放在一起</td>
<td></td>
</tr>
<tr>
<td align="center">8</td>
<td>工具栏的图标能直观地代表要完成的操作</td>
<td></td>
</tr>
<tr>
<td align="center">9</td>
<td>状态条能显示用户切实需要的信息。如果某一操作需要的时间较长，还应该显示进度条和进程提示</td>
<td></td>
</tr>
<tr>
<td align="center">10</td>
<td>滚动条的长度根据显示信息的长度或宽度及时变换</td>
<td></td>
</tr>
<tr>
<td align="center">11</td>
<td>菜单和工具栏有清楚的界限</td>
<td></td>
</tr>
<tr>
<td align="center">12</td>
<td>菜单和状态条通常使用5号字体</td>
<td></td>
</tr>
</tbody></table>
<h5 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h5><table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">快捷键类型</th>
<th>测试内容</th>
<th align="center">是否通过</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">编辑</td>
<td>Ctrl+A 全选；Ctrl+C 复制；Ctrl+V 粘贴；Ctrl+X 剪切；Ctrl+Z 撤销操作；Ctrl+Y 恢复操作；Ctrl+D 删除；Ctrl+F 寻找；Ctrl+H 替换；Ctrl+I 插入；Ctrl+Tab 下一个Tab窗口</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">文件操作</td>
<td>Ctrl+P 打印；Ctrl+W 关闭；Ctrl+N 新建；Ctrl+S 保存；Ctrl+O 打开</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">主菜单</td>
<td>Alt+F 文件；Alt+E编辑；Alt+W 窗口；Alt+H 帮助</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">Windows保留键</td>
<td>Ctrl+Esc 任务列表；Crtl+F4 关闭窗口；Alt+F4 结束应用；Alt+Tab 切换到下一应用；Enter 缺省按钮&#x2F;确认操作；Esc 取消按钮&#x2F;取消操作；Shift+F1 上下文相关帮助</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">其他组合</td>
<td>Alt+N 否；Alt+D 删除；Alt+Q 退出；Alt+A 添加；Alt+E 编辑；Alt+B 浏览；Alt+R 读；Alt+W 写</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h3><p>兼容测试简称CTS，指对所设计程序与硬件、软件之间的兼容性的测试<br>一般来说，兼容性指能同时容纳多个方面，在计算机术语上兼容是指几个硬件之间、几个软件之间或是软硬件之间的相互配合程度<br>对于我们测试来说，通俗一点的理解可以认为是被测软件在不同的硬件平台（PC&#x2F;Mobile），不同的软件（浏览器），不同的操作系统平台、不同的网络环境中是否能够很友好运行的测试</p>
<h4 id="兼容性测试–分类"><a href="#兼容性测试–分类" class="headerlink" title="兼容性测试–分类"></a>兼容性测试–分类</h4><ul>
<li>兼容性测试<ul>
<li>Web兼容测试<ul>
<li>浏览器兼容</li>
<li>屏幕尺寸、分辨率</li>
<li>操作系统</li>
</ul>
</li>
<li>APP兼容测试<ul>
<li>设备型号兼容测试</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="兼容性测试–作用"><a href="#兼容性测试–作用" class="headerlink" title="兼容性测试–作用"></a>兼容性测试–作用</h4><p>兼容性测试是软件测试过程必不可少的一个过程，没有兼容测试的测试是不完整的测试，兼容性测试的存在是有一定作用的</p>
<ol>
<li>兼容性测试能够进一步提高产品的质量，提高用户体验</li>
<li>兼容性测试能使软件与尽可能多的其他软件“和平共处”，尽可能达到平台无关性</li>
<li>兼容性测试能尽可能地保证软件存在地价值，它是衡量一个软件质量的重要指标</li>
<li>兼容性测试能够使软件产品的市场更广阔</li>
</ol>
<h4 id="Web兼容性测试"><a href="#Web兼容性测试" class="headerlink" title="Web兼容性测试"></a>Web兼容性测试</h4><h5 id="Web兼容性测试方向"><a href="#Web兼容性测试方向" class="headerlink" title="Web兼容性测试方向"></a>Web兼容性测试方向</h5><ul>
<li>浏览器兼容性</li>
<li>操作系统兼容性</li>
</ul>
<h5 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h5><ul>
<li>人工测试<br>测试工程师测试主流浏览器和常用操作系统测试主流程和主界面，看看主流程和主界面是否有问题</li>
<li>第三方测试工具<br>部分情况下，部分浏览器可以依赖第三方工具辅助测试</li>
</ul>
<h5 id="测试选型"><a href="#测试选型" class="headerlink" title="测试选型"></a>测试选型</h5><ul>
<li>Chrome: Webkit内核*1 &amp; Blink内核*1</li>
<li>Firefox: 最新版本</li>
<li>IE: 7-11</li>
<li>Safari: mac版本单独测试</li>
<li>Edge: Window10</li>
<li>360安全浏览器（双核版）</li>
<li>搜狗等其他浏览器任选其一</li>
<li>如有需要Linux系统下Firefox, ChromeOS下Chrome</li>
</ul>
<h5 id="三方工具–IETESTER"><a href="#三方工具–IETESTER" class="headerlink" title="三方工具–IETESTER"></a>三方工具–IETESTER</h5><p>可以进行IE5.5-IE11的兼容性测试，能够满足一定程度的测试需求，但随着IETESTER后期维护乏力，对浏览器的支持不足。同时目前对于IE兼容性来说，更多支持IE7+，我们可以使用IE浏览器自带的调试工具来测试，故IETESTER逐步从重要变成鸡肋</p>
<h5 id="三方工具–BrowserShots"><a href="#三方工具–BrowserShots" class="headerlink" title="三方工具–BrowserShots"></a>三方工具–BrowserShots</h5><p><a target="_blank" rel="noopener" href="http://www.browsershots.org通过在线截图的方式展现页面的兼容性.限制在于只可以通过输入网址的方式查看,对于还未上线,测试中的网站比较难于使用/">www.browsershots.org通过在线截图的方式展现页面的兼容性。限制在于只可以通过输入网址的方式查看，对于还未上线，测试中的网站比较难于使用</a></p>
<h5 id="三方工具–Super-Preview"><a href="#三方工具–Super-Preview" class="headerlink" title="三方工具–Super Preview"></a>三方工具–Super Preview</h5><p>SuperPreview是微软将推出的Expression Web3的一部分，同时，微软也提供了SuperPreview的独立安装包。他的目标是集成IETESTER和BrowserShots的功能，但是目前还没有完善</p>
<h4 id="APP兼容性测试"><a href="#APP兼容性测试" class="headerlink" title="APP兼容性测试"></a>APP兼容性测试</h4><h5 id="APP兼容性测试方向"><a href="#APP兼容性测试方向" class="headerlink" title="APP兼容性测试方向"></a>APP兼容性测试方向</h5><ul>
<li>硬件设备兼容性</li>
<li>操作系统版本兼容性</li>
</ul>
<h5 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h5><ul>
<li>使用TOP20的机型，指定系统版本</li>
<li>Android机一律要求使用真机或者相应的云服务测试，iOS允许使用模拟器</li>
<li>如果有的TOP20机型无法获取到，允许选取同类（iOS&#x2F;Android）机型作为代替，但最多不超过4个替代机型</li>
</ul>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body fs14"><div class="line"></div><a id="prev" href="/2022/06/13/Linux-Studying/">Linux_Studying<span class="note">较新</span></a></section></div>






  <div class='related-wrap md reveal' id="comments">
    <div class='cmt-title cap theme'>
      快来参与讨论吧
    </div>
    <div class='cmt-body beaudar'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="beaudar" repo="Fam044/bloghexo-comments" issue-term="pathname" theme="preferred-color-scheme" input-position="top" comment-order="desc" loading="false" branch="main"></div>

    </div>
  </div>



      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
<p>本站由 <a href="https://fam044.github.io/">@Fam044</a> 创建，使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0" title="v1.8.0">Stellar</a> 作为主题。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.8.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://fastly.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://fastly.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://fastly.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://fastly.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti/umd/heti.min.css","js":"https://unpkg.com/heti/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadBeaudar() {
    const els = document.querySelectorAll("#comments #beaudar");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://beaudar.lipk.org/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
      loadBeaudar();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
